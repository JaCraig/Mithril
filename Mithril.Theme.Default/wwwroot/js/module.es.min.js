var N = Object.defineProperty;
var H = (i, e, t) => e in i ? N(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t;
var S = (i, e, t) => (H(i, typeof e != "symbol" ? e + "" : e, t), t);
import F from "moment";
import A, { openBlock as p, createElementBlock as y, createTextVNode as B, Fragment as V, renderList as P, createBlock as U, resolveDynamicComponent as K, createElementVNode as g, toDisplayString as T, resolveDirective as O, withDirectives as q, withModifiers as I, normalizeClass as b } from "vue";
HTMLElement.prototype.getParentByClass = function(i) {
  let e = this.parentElement;
  for (; e && !e.hasClass(i); )
    e = e.parentElement;
  return e;
};
HTMLElement.prototype.hasClass = function(i) {
  return (" " + this.className + " ").indexOf(" " + i + " ") > -1;
};
HTMLElement.prototype.replaceClass = function(i, e) {
  let t = " " + this.className + " ";
  if (t.indexOf(i) === -1) {
    this.addClass(e);
    return;
  }
  e === "" ? this.className = t.replace(new RegExp(" " + i + " ", "gi"), " ").trim() : this.className = t.replace(new RegExp(" " + i + " ", "gi"), " " + e + " ").trim();
};
HTMLElement.prototype.toggleClass = function(i, e) {
  if (this.hasClass(i)) {
    this.replaceClass(i, e);
    return;
  }
  this.replaceClass(e, i);
};
HTMLElement.prototype.removeClass = function(i) {
  this.replaceClass(i, "");
};
HTMLElement.prototype.addClass = function(i) {
  this.hasClass(i) || (this.className += " " + i);
};
HTMLElement.prototype.show = function() {
  this.replaceClass("hidden", "show"), this.addClass("show");
};
HTMLElement.prototype.hide = function() {
  this.replaceClass("show", "hidden"), this.addClass("hidden");
};
HTMLElement.prototype.attribute = function(i, e = null) {
  return e != null ? (this.setAttribute(i, e), e) : this.getAttribute(i);
};
NodeList.prototype.map = function(i) {
  let e = [];
  for (let t = 0; t < this.length; ++t)
    e = e.concat(i(this[t]));
  return e;
};
NodeList.prototype.filter = function(i) {
  let e = [];
  for (let t = 0; t < this.length; ++t)
    i(this[t]) && (e = e.concat(this[t]));
  return e;
};
class R {
  constructor() {
    this.errors = [], this.messageAttributes = {}, this.messageAttributes.patternMismatch = "data-error-message-pattern-mismatch", this.messageAttributes.rangeOverflow = "data-error-message-range-overflow", this.messageAttributes.rangeUnderflow = "data-error-message-range-underflow", this.messageAttributes.stepMismatch = "data-error-message-step-mismatch", this.messageAttributes.tooLong = "data-error-message-too-long", this.messageAttributes.tooShort = "data-error-message-too-short", this.messageAttributes.badInput = "data-error-message-bad-input", this.messageAttributes.typeMismatch = "data-error-message-type-mismatch", this.messageAttributes.valueMissing = "data-error-message-value-missing";
  }
  // initializes the validation system for adding custom error messages
  initialize() {
    let e = this.map(document.getElementsByTagName("input"), (s) => s).filter((s) => s.willValidate);
    for (let s = 0; s < e.length; ++s)
      e[s].type.toUpperCase() === "RADIO" || e[s].type.toUpperCase() === "CHECKBOX" ? e[s].addEventListener("change", (a) => this.inputHandler(a.target)) : e[s].addEventListener("input", (a) => this.inputHandler(a.target)), e[s].addEventListener("invalid", (a) => this.invalidInputHandler(a.target));
    let t = this.map(document.getElementsByTagName("textarea"), (s) => s).filter((s) => s.willValidate);
    for (let s = 0; s < t.length; ++s)
      t[s].addEventListener("change", (a) => this.textAreaHandler(a.target)), t[s].addEventListener("invalid", (a) => this.invalidTextAreaHandler(a.target));
    let r = this.map(document.getElementsByTagName("select"), (s) => s).filter((s) => s.willValidate);
    for (let s = 0; s < r.length; ++s)
      r[s].addEventListener("change", (a) => this.selectHandler(a.target)), r[s].addEventListener("invalid", (a) => this.invalidSelectHandler(a.target));
  }
  map(e, t) {
    let r = [];
    for (let s = 0; s < e.length; ++s)
      r = r.concat(t(e[s]));
    return r;
  }
  filter(e, t) {
    let r = [];
    for (let s = 0; s < e.length; ++s)
      t(e[s]) && (r = r.concat(e[s]));
    return r;
  }
  // Initialize an individual form
  initializeForm(e) {
    let t = this.map(e.getElementsByTagName("input"), (a) => a).filter((a) => a.willValidate);
    for (let a = 0; a < t.length; ++a)
      t[a].type.toUpperCase() === "RADIO" || t[a].type.toUpperCase() === "CHECKBOX" ? t[a].addEventListener("change", (n) => this.inputHandler(n.target)) : t[a].addEventListener("input", (n) => this.inputHandler(n.target)), t[a].addEventListener("invalid", (n) => this.invalidInputHandler(n.target));
    let r = this.map(e.getElementsByTagName("textarea"), (a) => a).filter((a) => a.willValidate);
    for (let a = 0; a < r.length; ++a)
      r[a].addEventListener("change", (n) => this.textAreaHandler(n.target)), r[a].addEventListener("invalid", (n) => this.invalidTextAreaHandler(n.target));
    let s = this.map(e.getElementsByTagName("select"), (a) => a).filter((a) => a.willValidate);
    for (let a = 0; a < s.length; ++a)
      s[a].addEventListener("change", (n) => this.selectHandler(n.target)), s[a].addEventListener("invalid", (n) => this.invalidSelectHandler(n.target));
  }
  // invalid input handler
  invalidInputHandler(e) {
    if (!e.validity.valid) {
      let t = this.getErrorMessages(e, e.validity);
      t.length > 0 && e.setCustomValidity(t.join(`
`));
    }
  }
  // invalid text area handler
  invalidTextAreaHandler(e) {
    if (!e.validity.valid) {
      let t = this.getErrorMessages(e, e.validity);
      t.length > 0 && e.setCustomValidity(t.join(`
`));
    }
  }
  // invalid select handler
  invalidSelectHandler(e) {
    if (!e.validity.valid) {
      let t = this.getErrorMessages(e, e.validity);
      t.length > 0 && e.setCustomValidity(t.join(`
`));
    }
  }
  // Input handler
  inputHandler(e) {
    if (e.type.toUpperCase() === "RADIO") {
      let t = document.getElementsByName(e.name);
      for (let r = 0; r < t.length; ++r)
        t[r].setCustomValidity("");
    } else
      e.setCustomValidity("");
    e.checkValidity();
  }
  // text area handler
  textAreaHandler(e) {
    e.setCustomValidity(""), e.checkValidity();
  }
  // select handler
  selectHandler(e) {
    e.setCustomValidity(""), e.checkValidity();
  }
  // Validates all elements, returning false if there are errors, true otherwise.
  validate() {
    let e = !0;
    this.errors = [];
    let t = this.filter(
      document.getElementsByTagName("input"),
      (a) => !this.validateInput(a)
    );
    e = e && t.length === 0;
    let r = this.filter(
      document.getElementsByTagName("select"),
      (a) => !this.validateSelect(a)
    );
    e = e && r.length === 0;
    let s = this.filter(
      document.getElementsByTagName("textarea"),
      (a) => !this.validateTextArea(a)
    );
    return e = e && s.length === 0, e;
  }
  // Validates all elements in the form, returning the list of error messages.
  validateForm(e) {
    let t = [];
    this.errors = [];
    let r = this.filter(
      e.getElementsByTagName("input"),
      (n) => !this.validateInput(n)
    ).map((n) => this.getErrorMessages(n, n.validity)).filter((n) => n.length !== 0);
    for (let n = 0; n < r.length; ++n)
      t = t.concat(r[n]);
    let s = this.filter(
      e.getElementsByTagName("select"),
      (n) => !this.validateSelect(n)
    ).map((n) => this.getErrorMessages(n, n.validity)).filter((n) => n.length !== 0);
    for (let n = 0; n < s.length; ++n)
      t = t.concat(s[n]);
    let a = this.filter(
      e.getElementsByTagName("textarea"),
      (n) => !this.validateTextArea(n)
    ).map((n) => this.getErrorMessages(n, n.validity)).filter((n) => n.length !== 0);
    for (let n = 0; n < a.length; ++n)
      t = t.concat(a[n]);
    return t;
  }
  // Validates an individual element, returning the list of error messages.
  validateElement(e) {
    let t = [];
    if (e.tagName === "INPUT" && !this.validateInput(e)) {
      let r = this.getErrorMessages(e, e.validity).filter((s) => s.length !== 0);
      for (let s = 0; s < r.length; ++s)
        t = t.concat(r[s]);
    } else if (e.tagName === "SELECT" && !this.validateSelect(e)) {
      let r = this.getErrorMessages(e, e.validity).filter((s) => s.length !== 0);
      for (let s = 0; s < r.length; ++s)
        t = t.concat(r[s]);
    } else if (e.tagName === "TEXTAREA" && !this.validateTextArea(e)) {
      let r = this.getErrorMessages(e, e.validity).filter((s) => s.length !== 0);
      for (let s = 0; s < r.length; ++s)
        t = t.concat(r[s]);
    }
    return t;
  }
  // validates a select object
  validateSelect(e) {
    if (!e.checkValidity()) {
      let t = this.getErrorMessages(e, e.validity);
      return t.length !== 0 && (this.errors = this.errors.concat(t)), !1;
    }
    return !0;
  }
  // validates a text area object
  validateTextArea(e) {
    if (!e.checkValidity()) {
      let t = this.getErrorMessages(e, e.validity);
      return t.length !== 0 && (this.errors = this.errors.concat(t)), !1;
    }
    return !0;
  }
  // gets the error messages based on the validation state and element's defined error messages
  getErrorMessages(e, t) {
    let r = [];
    for (let s in this.messageAttributes)
      if (t[s]) {
        let a = e.attribute(this.messageAttributes[s]);
        a !== null && (r = r.concat(a));
      }
    if (r.length === 0) {
      let s = e.attribute("data-error-message");
      s !== null ? r = r.concat(s) : r = r.concat(e.validationMessage);
    }
    return r;
  }
  // validates an input object
  validateInput(e) {
    if (!e.checkValidity()) {
      let t = this.getErrorMessages(e, e.validity);
      return t.length !== 0 && (this.errors = this.errors.concat(t)), !1;
    }
    return !0;
  }
}
class j {
  //Constructor
  constructor() {
    this.params = [];
  }
  //Converts the class to a string
  toString() {
    let e = this.params.length > 0 ? "'" + this.params.join("', '") + "'" : "";
    return this.name + "(" + e + ")";
  }
}
Function.prototype.trace = function() {
  for (var i = [], e = this; e; )
    i.push(e.signature()), e = e.caller;
  return i;
};
Function.prototype.signature = function() {
  var i = new j();
  if (i.name = this.getName(), this.arguments)
    for (var e = 0; e < this.arguments.length; e++)
      i.params.push(this.arguments[e]);
  return i;
};
Function.prototype.getName = function() {
  if (this.name)
    return this.name;
  var i = this.toString().split(`
`)[0], e = /^function ([^\s(]+).+/;
  return e.test(i) && i.split(`
`)[0].replace(e, "$1") || "anonymous";
};
class $ {
  //constructor
  constructor() {
    this.logError = (e, t) => {
    };
  }
  //Sets the logging function that the system uses
  setLoggingFunction(e) {
    this.logError = e;
  }
  //called when an error is thrown.
  onError(e, t, r, s, a) {
    this.logError(e, (a == null ? void 0 : a.stack) || "");
  }
}
class z {
  // sets the value of an item for long term storage
  set(e, t) {
    localStorage.setItem(e, t);
  }
  // sets the value of an item for long term storage (used when saving objects)
  setObject(e, t) {
    this.set(e, JSON.stringify(t));
  }
  // gets a value based on the key specified
  get(e, t = "") {
    return localStorage.getItem(e) || t;
  }
  // Returns true if the key is present in local storage, false otherwise.
  has(e) {
    return this.get(e, null) !== null;
  }
  // Removes an item from local storage
  remove(e) {
    localStorage.removeItem(e);
  }
  // Clears local storage of all items
  clear() {
    localStorage.clear();
  }
  // Returns the number of items in storage
  get length() {
    return localStorage.length;
  }
  // Gets the key of the item at the index specified
  key(e) {
    return localStorage.key(e);
  }
  // gets a value based on the key specified (used when saving objects)
  getObject(e, t = null) {
    let r = this.get(e);
    return r && JSON.parse(r) || t;
  }
}
class Y {
  // sets the value of an item for long term storage
  set(e, t) {
    sessionStorage.setItem(e, t);
  }
  // sets the value of an item for long term storage (used when saving objects)
  setObject(e, t) {
    this.set(e, JSON.stringify(t));
  }
  // gets a value based on the key specified
  get(e, t = "") {
    return sessionStorage.getItem(e) || t;
  }
  // Returns true if the key is present in local storage, false otherwise.
  has(e) {
    return this.get(e, null) !== null;
  }
  // Removes an item from local storage
  remove(e) {
    sessionStorage.removeItem(e);
  }
  // Clears local storage of all items
  clear() {
    sessionStorage.clear();
  }
  // Returns the number of items in storage
  get length() {
    return sessionStorage.length;
  }
  // Gets the key of the item at the index specified
  key(e) {
    return sessionStorage.key(e);
  }
  // gets a value based on the key specified (used when saving objects)
  getObject(e, t = null) {
    let r = this.get(e);
    return r && JSON.parse(r) || t;
  }
}
class D {
  // constructor
  constructor(e, t, r) {
    this.DBName = e, this.Version = r;
    let s = indexedDB.open(e, r);
    s.onupgradeneeded = (a) => {
      this.database = a.target.result;
      for (let n = 0; n < t.length; ++n) {
        let o = t[n];
        this.database.objectStoreNames.contains(o) && this.database.deleteObjectStore(o), this.database.createObjectStore(o);
      }
    }, s.onsuccess = (a) => {
      this.database = a.target.result;
    };
  }
  // open the database table
  openDatabase(e) {
    let t = indexedDB.open(this.DBName, this.Version);
    t.onsuccess = (r) => (this.database = r.target.result, e(this));
  }
  add(e, t, r) {
    this.database.transaction(e, "readwrite").objectStore(e).put(t, r);
  }
  remove(e, t) {
    this.database.transaction(e, "readwrite").objectStore(e).delete(t);
  }
  getByKey(e, t, r) {
    let s = this.database.transaction(e, "readwrite").objectStore(e).get(t);
    s.onsuccess = r;
  }
  getKeys(e, t) {
    let r = this.database.transaction(e, "readwrite").objectStore(e).getAllKeys();
    r.onsuccess = t;
  }
  get(e, t, r) {
    let s = this.database.transaction(e, "readwrite").objectStore(e).get(t);
    s.onsuccess = r;
  }
  getAll(e, t, r) {
    let s = this.database.transaction(e, "readwrite").objectStore(e).getAll(r);
    s.onsuccess = t;
  }
}
class l {
  // Constructor
  constructor(e, t, r) {
    this.url = t, this.method = e.toUpperCase(), this.data = r, this.headers = new Headers(), this.method !== "GET" && this.method !== "HEAD" && this.method !== "DELETE" && this.method !== "TRACE" && this.type("application/json"), this.accept("application/json"), this.parser = (s) => s.json(), this.serializer = (s) => JSON.stringify(s), this.storageMode = 2, this.databaseName = "MithrilStorage", this.cacheKey = this.url + this.serializer(this.data), this.credentials = "same-origin";
  }
  // GET method.
  static get(e, t) {
    return l.makeRequest("GET", e, t);
  }
  // A request using a HTTP verb that is not GET, POST, PUT, or DELETE
  static makeRequest(e, t, r) {
    return new l(e, t, r);
  }
  // POST method.
  static post(e, t) {
    return l.makeRequest("POST", e, t);
  }
  // PUT method.
  static put(e, t) {
    return l.makeRequest("PUT", e, t);
  }
  // DELETE method.
  static delete(e, t) {
    return l.makeRequest("DELETE", e, t);
  }
  // Adds a callback to call if the AJAX request succeeds.
  onSuccess(e) {
    return this.success = e, this;
  }
  // Adds a callback to call if the AJAX request fails.
  onError(e) {
    return this.error = e, this;
  }
  // Adds a header value to the AJAX request.
  setHeader(e, t) {
    return this.headers.set(e, t), this;
  }
  // Sets the cache key
  setCacheKey(e) {
    return this.cacheKey = e, this;
  }
  // Sets the credentials type used for the call
  setCredentials(e) {
    return this.credentials = e, this;
  }
  // Short hand for setting the content type header value
  type(e) {
    return this.setHeader("Content-Type", e);
  }
  // Short hand for setting the accepts header value
  accept(e) {
    return this.setHeader("Accept", e);
  }
  // Sets the parser that the request uses
  setParser(e) {
    return this.parser = e, this;
  }
  // Ensures that the result of the request will be cached and used in future requests.
  setMode(e, t = "MithrilStorage") {
    return this.databaseName = t, this.storageMode = e, this;
  }
  // Sets the serializer that the request uses
  setSerializer(e) {
    return this.serializer = e, this;
  }
  // Actually sends the request, parses it, and calls either the
  // success or error functions if they exist.
  send() {
    (this.error === void 0 || this.error === null) && (this.error = (t) => {
    }), (this.success === void 0 || this.success === null) && (this.success = (t) => {
    });
    let e = this.serializer(this.data);
    if (this.storageMode === 1) {
      l.returnValueFromDB(this.cacheKey, this.databaseName, this.success), this.queryNetwork(e, this.cacheKey, this.databaseName, (t) => {
      }, (t) => {
        l.saveValueToDB(t, this.cacheKey, this.databaseName);
      });
      return;
    }
    if (this.storageMode === 3) {
      l.returnValueFromDB(this.cacheKey, this.databaseName, this.success), this.queryNetwork(e, this.cacheKey, this.databaseName, (t) => {
      }, (t) => {
        l.saveValueToDB(t, this.cacheKey, this.databaseName), this.success(t);
      });
      return;
    }
    if (this.storageMode === 0) {
      this.queryNetwork(e, this.cacheKey, this.databaseName, this.success, (t) => {
        l.saveValueToDB(t, this.cacheKey, this.databaseName), this.success(t);
      });
      return;
    }
    this.queryNetwork(e, this.cacheKey, this.databaseName, (t) => {
    }, this.success);
  }
  // Saves a value to the database/cache
  static saveValueToDB(e, t, r) {
    new D(r, ["cache", "cacheExpirations"], 1).openDatabase((s) => {
      e !== void 0 && (s.add("cache", e, t), s.add("cacheExpirations", Date.now(), t));
    });
  }
  // Queries the network and saves the data to the appropriate cache table.
  queryNetwork(e, t, r, s, a) {
    if (!navigator.onLine) {
      this.storageMode === 0 && l.returnValueFromDB(t, r, s);
      return;
    }
    fetch(this.url, {
      credentials: this.credentials,
      method: this.method,
      body: e,
      headers: this.headers
    }).then(this.parser).then(a).catch(this.error);
  }
  // Gets the value in the database and returns that for success.
  static returnValueFromDB(e, t, r) {
    new D(t, ["cache", "cacheExpirations"], 1).openDatabase((s) => {
      s.getByKey("cache", e, (a) => {
        let n = a.target.result;
        n !== void 0 && r(n);
      });
    });
  }
}
var x = /* @__PURE__ */ ((i) => (i[i.NetworkFirst = 0] = "NetworkFirst", i[i.StorageFirst = 1] = "StorageFirst", i[i.NetworkOnly = 2] = "NetworkOnly", i[i.StorageAndUpdate = 3] = "StorageAndUpdate", i))(x || {});
class E {
  // Returns the current domain.
  static get domain() {
    return window.location.protocol + "//" + window.location.host + "/";
  }
  // Determines if this is being run locally or in production.
  static get isLocal() {
    return /^http:\/\/localhost:\d{5}\/$/.test(E.domain);
  }
  // Gets the hash without the hash bang.
  static get HashBang() {
    return window.location.hash.replace("#!", "");
  }
  // Gets the text after the last slash. Presumably the ID needed.
  static get Id() {
    return window.location.pathname.substring(window.location.pathname.lastIndexOf("/") + 1);
  }
  // Gets a value from the query string.
  static GetQueryString(e) {
    let t = window.location.href;
    var r = new RegExp("[?&]" + e + "=([^&#]*)", "i"), s = r.exec(t);
    return s ? s[1] : null;
  }
  // Sets the title for the page.
  static setPageTitle(e) {
    document.title = e;
  }
}
class f {
}
f.keyMappings = {
  BACKSPACE: 8,
  TAB: 9,
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  PAUSE: 19,
  CAPSLOCK: 20,
  ESCAPE: 27,
  SPACE: 32,
  PAGEUP: 33,
  PAGEDOWN: 34,
  END: 35,
  HOME: 36,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  INS: 45,
  DEL: 46,
  META: 91,
  "*": 106,
  "+": 107,
  MINUS: 109,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  NUMLOCK: 144,
  SCROLLLOCK: 145,
  ";": 186,
  "=": 187,
  "": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
class G {
  // Constructor
  constructor(e) {
    this.keys = this.getKeys(e);
  }
  // gets the key codes for the string passed in
  getKeys(e) {
    return e.toUpperCase().split(/-(?!$)/).map((t) => f.keyMappings[t] || t.charCodeAt(0));
  }
  // determines if the key code is pressed
  isPressed(e) {
    let t = e;
    if (t.length !== this.keys.length)
      return !1;
    for (let r = 0; r < t.length; ++r)
      if (this.keys.indexOf(t[r]) === -1)
        return !1;
    return !0;
  }
}
class Q {
  // constructor
  constructor(e, t) {
    this.keyCodeSequence = e.toUpperCase(), this.keyCodes = e.toUpperCase().split(" ").map((r) => new G(r)), this.callback = t, this.length = this.keyCodes.length, this.isDefault = e === "<*>";
  }
  // calls the callback function with the data specified
  call(e, t, r) {
    return this.callback(t, { scope: r, keysPressed: e }), !0;
  }
  // Runs the callback based on the keycode being pressed
  press(e, t, r) {
    let s = e;
    if (s.length !== this.length)
      return !1;
    for (let a = 0; a < this.keyCodes.length; ++a)
      if (!this.keyCodes[a].isPressed(s[a]))
        return !1;
    return this.call(e, t, r);
  }
  // determines if this is a partial match on a sequence
  isPartial(e) {
    let t = e;
    if (t.length > this.length)
      return !1;
    for (let r = 0; r < t.length; ++r)
      if (!this.keyCodes[r].isPressed(t[r]))
        return !1;
    return !0;
  }
}
class v {
  // constructor
  constructor(e) {
    this.name = e, this.sequences = [];
  }
  // determines if anything in this scope was pressed
  press(e, t) {
    this.sequences = this.sequences.sort((r, s) => r.length > s.length ? 1 : -1);
    for (let r = 0; r < this.sequences.length; ++r)
      if (this.sequences[r].press(e, t, this))
        return !0;
    return !1;
  }
  // calls the default handler if one exists
  callDefault(e, t) {
    let r = this.sequences.filter((s) => s.isDefault);
    return r.length === 0 ? !1 : r[0].call(e, t, this);
  }
  // determines if the sequence is a partial match
  isPartial(e) {
    for (let t = 0; t < this.sequences.length; ++t)
      if (this.sequences[t].isPartial(e))
        return !0;
    return !1;
  }
  // adds an individual sequence to the scope
  addSequence(e, t) {
    return this.removeSequence(e), this.sequences.push(new Q(e, t)), this;
  }
  // removes an individual sequence from the scope
  removeSequence(e) {
    return this.sequences = this.sequences.filter((t) => t.keyCodeSequence !== e.toUpperCase()), this;
  }
  // clears the sequences and scopes from the scope
  clear() {
    return this.sequences = [], this;
  }
}
class J {
  // constructor
  constructor() {
    this.scopes = {}, this.scopes.Default = new v("Default"), this.currentScope = this.scopes.Default, this.filter = (e) => {
      let t = (e.target || e.srcElement).tagName;
      return t !== "INPUT" && t !== "SELECT" && t !== "TEXTAREA";
    }, this.latestKeys = [];
  }
  // Sets the current scope, adding it if it doesn't exist and returns it.
  setScope(e) {
    let t = this.addScope(e);
    return this.currentScope = t, t;
  }
  // Adds a scope to the system and returns it (or returns it if it already exists)
  addScope(e) {
    let t = this.scopes[e];
    return t !== void 0 || (t = new v(e), this.scopes[e] = t), t;
  }
  // Removes a scope from the system
  removeScope(e) {
    return this.scopes[e] = void 0, e === "Default" && (this.scopes.Default = new v("Default")), this.currentScope.name === e && (this.currentScope = this.scopes.Default), this;
  }
  // clears all scopes and creates a new Default scope
  clear() {
    return this.scopes = {}, this.scopes.Default = new v("Default"), this.currentScope = this.scopes.Default, this.latestKeys = [], this;
  }
  // adds a sequence to the current scope
  bind(e, t) {
    return this.currentScope.addSequence(e, t), this;
  }
  // removes a sequence from the current scope
  unbind(e) {
    return this.currentScope.removeSequence(e), this;
  }
  // Called when a press event is fired
  press(e) {
    if (!this.filter(e))
      return;
    let t = this.getKeys(e);
    this.latestKeys.push(t);
    let r = this.latestKeys.slice();
    if (this.currentScope.press(this.latestKeys, e))
      this.latestKeys = [];
    else {
      for (; this.latestKeys.length > 0; ) {
        if (this.currentScope.isPartial(this.latestKeys))
          return;
        this.latestKeys.shift();
      }
      this.latestKeys.length === 0 && this.currentScope.callDefault(r, e);
    }
  }
  // gets the string version of the keys currently pressed
  getKeys(e) {
    let t = [];
    return e.altKey && t.push(f.keyMappings.ALT), e.ctrlKey && t.push(f.keyMappings.CTRL), e.metaKey && t.push(f.keyMappings.META), e.shiftKey && t.push(f.keyMappings.SHIFT), t.indexOf(e.keyCode) === -1 && t.push(e.keyCode), t;
  }
}
class C {
}
class X {
  //Constructor
  constructor(e, t) {
    this.variable = e.charAt(0) === "{" && e.charAt(e.length - 1) === "}", e = e.replace(/[{}]/g, ""), this.optional = e.charAt(0) === "^", this.part = e.replace(/[\^]/g, ""), t[this.part] !== void 0 ? this.defaultValue = t[this.part] : this.defaultValue = "";
  }
  //Determines if this is a match.
  isMatch(e) {
    return e == null ? this.optional : (e = e, this.variable ? this.optional || e !== "" : this.optional || e.toUpperCase() === this.part.toUpperCase());
  }
  //Gets the value, if it is a variable. If it is not a variable, it returns undefined and if it is a variable but no
  //value is present it returns null.
  getValue(e) {
    return this.variable ? e !== void 0 ? e || this.defaultValue : this.defaultValue : e || this.defaultValue;
  }
  //Sets the value used for the path part
  setValue(e, t) {
    this.getValue(e), t[this.part] = this.getValue(e);
  }
}
class W {
  // Constructor
  constructor(e, t) {
    let r = e.split("=", 2);
    this.key = r[0], e = r[1], this.variable = e.charAt(0) === "{" && e.charAt(e.length - 1) === "}", e = e.replace(/[{}]/g, ""), this.optional = e.charAt(0) === "^", this.part = e.replace(/[\^]/g, ""), t[this.part] !== void 0 ? this.defaultValue = t[this.part] : this.defaultValue = "";
  }
  // Determines if this is a match.
  isMatch(e) {
    if (e == null)
      return !1;
    let t = e.split("=", 2);
    return t.length !== 2 || this.key.toUpperCase() !== t[0].toUpperCase() ? !1 : (e = t[1], e === void 0 ? this.optional : this.variable ? this.optional || e !== "" : this.optional || e.toUpperCase() === this.part.toUpperCase());
  }
  // Gets the value, if it is a variable. If it is not a variable, it returns undefined and if it is a variable but no
  // value is present it returns null.
  getValue(e) {
    if (e == null)
      return this.defaultValue;
    let t = e.split("=", 2);
    return t.length !== 2 ? this.defaultValue : (e = t[1], this.variable ? e !== void 0 ? e || this.defaultValue : this.defaultValue : e || this.defaultValue);
  }
  // Sets the value used for the path part
  setValue(e, t) {
    this.getValue(e), t[this.key] = this.getValue(e);
  }
}
class Z {
  // Constructor
  constructor(e, t) {
    e = e.replace(/[#!]/g, ""), this.variable = e.charAt(0) === "{" && e.charAt(e.length - 1) === "}", e = e.replace(/[{}]/g, ""), this.optional = e.charAt(0) === "^", this.part = e.replace(/[\^]/g, ""), t[this.part] !== void 0 ? this.defaultValue = t[this.part] : this.defaultValue = "";
  }
  // Determines if this is a match.
  isMatch(e) {
    return e == null ? this.optional : (e = e.replace(/[#!]/g, ""), this.variable ? this.optional || e !== "" : this.optional || e.toUpperCase() === this.part.toUpperCase());
  }
  // Gets the value, if it is a variable. If it is not a variable, it returns undefined and if it is a variable but no
  // value is present it returns null.
  getValue(e) {
    return this.variable ? e !== void 0 ? e || this.defaultValue : this.defaultValue : e || this.defaultValue;
  }
  // Sets the value used for the path part
  setValue(e, t) {
    e = e || "", e = e.replace(/[#!]/g, ""), t[this.part] = this.getValue(e);
  }
}
class _ {
  // Constructor
  constructor(e, t, r) {
    r === void 0 && (r = new C()), this.url = this.fixUrl(e), this.pathParts = this.getPathParts(this.url).map((s) => new X(s, r)), this.pathParts = this.pathParts ? this.pathParts : [], this.queryParts = this.getQueryParts(this.url).map((s) => new W(s, r)), this.queryParts = this.queryParts ? this.queryParts : [], this.hashParts = this.getHashParts(this.url).map((s) => new Z(s, r)), this.hashParts = this.hashParts ? this.hashParts : [], this.callbacks = [t], this.defaultValues = r;
  }
  // Determines if the url passed in equals the current route
  isRoute(e) {
    return this.url === this.fixUrl(e);
  }
  // adds a callback to the route
  addCallback(e) {
    this.callbacks.push(e);
  }
  // removes a callback from the route
  removeCallback(e) {
    this.callbacks = this.callbacks.filter((t) => t !== e);
  }
  // Fixes a url that is passed in
  fixUrl(e) {
    return e.length ? e.replace(/^\//, "").replace(/\/+/g, "/").replace(/^\/|\/($|\?)/, "").replace(/\/\#/g, "#") : e;
  }
  // Get the path parts for the route
  getPathParts(e) {
    return e.split("?", 2)[0].split("#", 2)[0].split("/");
  }
  // Gets the hash code portion of the url
  getHashParts(e) {
    let t = e.split("?", 2)[0].split("#", 2);
    return t.length < 2 ? [] : [t[1].replace("!", "")];
  }
  // Gets the query string parts of the url
  getQueryParts(e) {
    let t = e.split("?", 2);
    return t.length < 2 ? [] : (e = t[1], e ? e.split("&") : []);
  }
  // Gets the parameters from the url specified
  getParametersFromUrl(e, t, r) {
    let s = new C();
    for (let a = 0; a < e.length; ++a)
      this.pathParts[a].setValue(e[a], s);
    for (let a = 0; a < t.length; ++a)
      this.queryParts[a].setValue(t[a], s);
    for (let a = 0; a < r.length; ++a)
      this.hashParts[a].setValue(r[a], s);
    if (this.pathParts.length > e.length)
      for (let a = e.length; a < this.pathParts.length; ++a)
        this.pathParts[a].setValue("", s);
    if (this.queryParts.length > t.length)
      for (let a = t.length; a < this.queryParts.length; ++a)
        this.queryParts[a].setValue("", s);
    if (this.hashParts.length > r.length)
      for (let a = r.length; a < this.hashParts.length; ++a)
        this.hashParts[a].setValue("", s);
    return s;
  }
  // Determines if the route is a match
  isMatch(e, t, r) {
    if (this.pathParts.length < e.length)
      return !1;
    for (let s = 0; s < e.length; ++s)
      if (!this.pathParts[s].isMatch(e[s]))
        return !1;
    if (this.pathParts.length > e.length) {
      for (let s = e.length; s < this.pathParts.length; ++s)
        if (!this.pathParts[s].isMatch(""))
          return !1;
    }
    if (this.queryParts.length < t.length)
      return !1;
    for (let s = 0; s < t.length; ++s)
      if (!this.queryParts[s].isMatch(t[s]))
        return !1;
    if (this.queryParts.length > t.length) {
      for (let s = t.length; s < this.queryParts.length; ++s)
        if (!this.queryParts[s].isMatch(""))
          return !1;
    }
    if (this.hashParts.length < r.length)
      return !1;
    for (let s = 0; s < r.length; ++s)
      if (!this.hashParts[s].isMatch(r[s]))
        return !1;
    if (this.hashParts.length > r.length) {
      for (let s = r.length; s < this.hashParts.length; ++s)
        if (!this.hashParts[s].isMatch(""))
          return !1;
    }
    return !0;
  }
  // Calls the route's callback function
  run(e) {
    e = this.fixUrl(e);
    let t = this.getPathParts(e), r = this.getQueryParts(e), s = this.getHashParts(e);
    if (!this.isMatch(t, r, s))
      return !1;
    let a = this.getParametersFromUrl(t, r, s);
    return a.url = e, this.callbacks.forEach((n) => n(a)), !0;
  }
}
class ee {
  // Constructor
  constructor() {
    this.routes = [];
  }
  // Maps a set of routes to the action specified
  map(e) {
    for (let t = 0; t < e.length; ++t)
      this.addRoute(e[t].url, e[t].action, e[t].defaultValues);
  }
  // Adds a route to the router
  addRoute(e, t, r) {
    let s = this.routes.filter((a) => a.isRoute(e));
    return s.length === 0 ? this.routes.push(new _(e, t, r)) : s[0].addCallback(t), this;
  }
  // Runs the url specified and returns true if it ran successfully, false otherwise.
  run(e) {
    for (let t = 0; t < this.routes.length; ++t)
      if (this.routes[t].run(e))
        return !0;
    return !1;
  }
}
class te {
  // Goes back by the value specified
  back(e) {
    e === void 0 && (e = 1), window.history.go(-1 * e);
  }
  // Goes forward by the value specified
  forward(e) {
    e === void 0 && (e = 1), window.history.go(e);
  }
  // pushes a new url/state onto the history
  push(e, t, r) {
    window.history.pushState(e, r, t);
  }
  // replaces the current url with a new url/state
  replace(e, t, r) {
    window.history.replaceState(e, r, t);
  }
  // gets the current state
  get state() {
    return window.history.state;
  }
  // Returns the number of items in storage
  get length() {
    return window.history.length;
  }
}
class we {
  // Exports the array of entries to the file specified
  static exportData(e, t, r = E.Id, s = 0) {
    if (e.length == 0)
      return;
    r = r || E.Id;
    let a = "";
    s === 0 ? a = this.exportCSV(e, t, r) : a = e.join(","), this.download(a, r);
  }
  // Capitalizes a string's first character
  static capitalize(e) {
    return e ? e.charAt(0).toUpperCase() + e.slice(1) : "";
  }
  // Exports a CSV of the data
  static exportCSV(e, t, r) {
    var o, w;
    let s = "", a = Object.keys(e[0]), n = "";
    for (let u = 0; u < a.length; ++u) {
      let c = a[u], d = t.filter(function(M) {
        return M.property === c;
      });
      d.length === 0 && (d = [{ display: c, property: c }]);
      let m = ((o = d[0]) == null ? void 0 : o.display) || ((w = d[0]) == null ? void 0 : w.property) || c;
      s += n + '"' + this.capitalize(m) + '"', n = ",";
    }
    s += `
`;
    for (let u = 0; u < e.length; ++u) {
      let c = e[u], d = Object.keys(c);
      n = "";
      for (let m = 0; m < d.length; ++m)
        s += n + '"' + c[d[m]].replaceAll('"', "'") + '"', n = ",";
      s += `
`;
    }
    return s;
  }
  // Downloads the data as the file specified
  static download(e, t) {
    if (e != null) {
      if (navigator.msSaveBlob) {
        navigator.msSaveBlob(new Blob([e]), t);
        return;
      }
      var r = document.createElement("a");
      r.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(e)), r.setAttribute("download", t), r.style.display = "none", document.body.appendChild(r), r.click(), document.body.removeChild(r);
    }
  }
}
class se {
  // constructor
  constructor() {
    this.validation = new R(), this.errorLogger = new $(), this.localStorage = new z(), this.sessionStorage = new Y(), this.hotkeys = new J(), this.router = new ee(), this.history = new te(), window.addEventListener("keydown", (e) => this.hotkeys.press(e)), window.addEventListener("load", (e) => this.validation.initialize(), !1), window.onerror = (e, t, r, s, a) => {
      this.errorLogger.onError(e.toString(), t, r, s, a);
    }, this.errorLogger.setLoggingFunction((e, t) => {
      console.log(e);
    });
  }
}
let h = {
  mounted: function(i, e) {
    if (h.onEventBound = h.onEvent.bind({ el: i }), document.addEventListener("click", h.onEventBound), typeof e.value != "function")
      throw new Error("Argument must be a function");
    h.cb = e.value;
  },
  cb: function(i) {
  },
  onEvent: function(i) {
    i.target === this.el || this.el.contains(i.target) || !h.cb || h.cb(i);
  },
  onEventBound: function() {
  },
  unbind: function() {
    document.removeEventListener("click", h.onEventBound);
  },
  update: function(i, e) {
    if (typeof e.value != "function")
      throw new Error("Argument must be a function");
    h.cb = e.value;
  }
};
function re(i) {
  return i.directive("click-outside", h), i;
}
function ie(i) {
  return i == null || (i.config.globalProperties.$filters = {
    moment: function(e, t, r) {
      return e == null ? "N/A" : (r ?? (r = "YYYY-MM-DDThh:mm:ss"), t ?? (t = "M-D-YYYY h:mm A"), F(e, r).format(t));
    },
    capitalize: function(e) {
      return e == null ? "" : e.charAt(0).toUpperCase() + e.slice(1);
    },
    maxsize: function(e, t, r) {
      return e == null ? "" : e.length <= t ? e : (r ?? (r = "..."), e.substring(0, t) + r);
    },
    currency: function(e, t, r) {
      return e == null ? "" : (t ?? (t = "en-US"), r ?? (r = { style: "currency", currency: "USD" }), Intl.NumberFormat(t, r).format(e));
    }
  }), i;
}
class k {
}
String.prototype.slugify = function() {
  return this.trim().replace(/ /g, "-").replace(/-{2,}/g, "-").replace(/^-+|-+$/g, "").replace(/([^a-zA-Z0-9-_/./:]+)/g, "");
};
String.prototype.stripHTML = function() {
  let i = document.createElement("div");
  return i.innerHTML = this, (i.textContent || i.innerText || "").replace(/^\s+|\s+$/g, "");
};
String.prototype.toNumber = function() {
  return this == null ? 0 : parseFloat(this.stripHTML().replace(/[^0-9.-]/g, ""));
};
const ae = A.defineComponent({
  name: "DataHandler",
  data: function() {
    return {
      count: 0,
      timer: 0,
      internalData: this.model
    };
  },
  props: {
    model: {
      type: Object,
      default: {}
    },
    schema: {
      type: k,
      default: new k()
    }
  },
  methods: {
    fetchData: function() {
      if (!this.schema.loadUrl)
        return;
      let i = this;
      l.post("/api/query", {
        query: i.schema.datalistQuery
      }).onSuccess((e) => {
        i.schema.datalist = e.data.dropDown;
      }).setMode(x.StorageAndUpdate).send();
    },
    saveData: function() {
    },
    deleteData: function() {
    }
  },
  created: function() {
    if (!this.schema.datalistQuery)
      return;
    this.fetchData();
  },
  watch: {
    model: function(i, e) {
      e !== i && (this.internalModel = i);
    }
  }
}), L = (i, e) => {
  const t = i.__vccOpts || i;
  for (const [r, s] of e)
    t[r] = s;
  return t;
};
function ne(i, e, t, r, s, a) {
  return p(), y("div", null, [
    B(" ASDF "),
    (p(!0), y(V, null, P(i.schema.children, (n) => (p(), U(K(n.type), {
      key: n.type,
      data: i.internalData,
      schema: n,
      onSave: i.saveData,
      onDelete: i.deleteData,
      onLoad: i.fetchData
    }, null, 40, ["data", "schema", "onSave", "onDelete", "onLoad"]))), 128)),
    g("pre", null, T(i.internalData), 1)
  ]);
}
const le = /* @__PURE__ */ L(ae, [["render", ne]]), oe = A.defineComponent({
  data: function() {
    return {
      items: this.items,
      showDropDown: !1
    };
  },
  props: {
    items: Array
  },
  methods: {
    showDropDownFunc: function() {
      this.showDropDown = !0;
    },
    hideDropDownFunc: function() {
      this.showDropDown = !1;
    }
  },
  directives: {
    clickOutside: h
  }
}), he = { class: "unstyled" }, ue = { class: "grouped" }, ce = ["href"];
function de(i, e, t, r, s, a) {
  const n = O("click-outside");
  return q((p(), y("ul", he, [
    g("li", null, [
      g("a", {
        class: "fas fa-circle-user",
        href: "#",
        onClick: e[0] || (e[0] = I((...o) => i.showDropDownFunc && i.showDropDownFunc(...o), ["stop", "prevent"]))
      }),
      g("div", {
        class: b({ show: i.showDropDown, "z-depth-2": i.showDropDown, hidden: !i.showDropDown })
      }, [
        g("ul", ue, [
          (p(!0), y(V, null, P(i.items, (o) => (p(), y("li", {
            key: o.display
          }, [
            g("a", {
              href: o.url,
              class: b([o.icon])
            }, T(o.display), 11, ce)
          ]))), 128))
        ])
      ], 2)
    ])
  ])), [
    [n, i.hideDropDownFunc]
  ]);
}
const ge = /* @__PURE__ */ L(oe, [["render", de]]), fe = (i) => {
  i.component("mithril-data-handler", le), i.component("mithril-side-menu", ge);
}, pe = {
  install: (i, e) => {
    ie(i), re(i), fe(i);
  }
};
class me {
  // constructor
  constructor() {
    this.framework = new se(), this.setupLogging();
  }
  // Sets up Vue components
  SetupComponents(e) {
    return e.use(pe), e;
  }
  // Set up error logging.
  setupLogging() {
    var e = !1;
    this.framework.errorLogger.setLoggingFunction(function(t, r) {
      if (!(t === null || e)) {
        e = !0;
        var s = document.location, a = r, n = t;
        n += ": at document path '" + s + "'.", a !== null && (n += `
 at ` + a), l.post("API/Command/v1/Log", { logLevel: "Error", message: n }).send();
      }
    });
  }
}
class Se {
  constructor() {
    S(this, "Core");
    this.Core = new me();
  }
}
export {
  E as BrowserUtils,
  D as DatabaseConnection,
  we as Downloader,
  me as Mithril,
  l as Request,
  x as StorageMode,
  Se as ThemeStartup
};

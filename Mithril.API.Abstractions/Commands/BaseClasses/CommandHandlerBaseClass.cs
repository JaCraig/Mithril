using Mithril.API.Abstractions.Commands.Interfaces;
using System.Dynamic;

namespace Mithril.API.Abstractions.Commands.BaseClasses
{
    /// <summary>
    /// Command handler base class
    /// </summary>
    /// <typeparam name="TCommand">The type of the command.</typeparam>
    /// <seealso cref="ICommandHandler"/>
    public abstract class CommandHandlerBaseClass<TCommand> : ICommandHandler
        where TCommand : class
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CommandHandlerBaseClass{TCommand}"/> class.
        /// </summary>
        protected CommandHandlerBaseClass()
        {
        }

        /// <summary>
        /// Gets the command type accepted.
        /// </summary>
        /// <value>The command type accepted.</value>
        public Type CommandTypeAccepted { get; } = typeof(TCommand);

        /// <summary>
        /// Creates the specified value.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <returns>A command value converted from the ExpandoObject.</returns>
        public abstract ICommand? Create(ExpandoObject value);

        /// <summary>
        /// Handles the Command.
        /// </summary>
        /// <param name="arg">The argument.</param>
        /// <returns>Any events that are spawned by the command.</returns>
        public IEvent[] HandleCommand(params ICommand[] arg)
        {
            arg ??= Array.Empty<ICommand>();
            var Items = arg.Select(x => x as TCommand).Where(x => x is not null).ToArray();
            if (Items.Length == 0)
                return Array.Empty<IEvent>();
            return HandleCommand(Items!) ?? Array.Empty<IEvent>();
        }

        /// <summary>
        /// Handles the command.
        /// </summary>
        /// <param name="args">The arguments.</param>
        /// <returns>The events generated by the command.</returns>
        protected abstract IEvent[] HandleCommand(params TCommand[] args);
    }
}
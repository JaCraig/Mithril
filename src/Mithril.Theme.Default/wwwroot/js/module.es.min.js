var G = Object.defineProperty;
var _ = (i, e, t) => e in i ? G(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : i[e] = t;
var V = (i, e, t) => _(i, typeof e != "symbol" ? e + "" : e, t);
import X from "moment";
import I, { createElementBlock as D, openBlock as S, createTextVNode as Z, createElementVNode as b, Fragment as N, renderList as R, createBlock as ee, resolveDynamicComponent as te, toDisplayString as H, resolveDirective as re, withDirectives as se, withModifiers as ie, normalizeClass as q } from "vue";
class ne {
  // sets the value of an item for long term storage
  set(e, t) {
    localStorage.setItem(e, t);
  }
  // sets the value of an item for long term storage (used when saving objects)
  setObject(e, t) {
    this.set(e, JSON.stringify(t));
  }
  // gets a value based on the key specified
  get(e, t = "") {
    return localStorage.getItem(e) || t;
  }
  // Returns true if the key is present in local storage, false otherwise.
  has(e) {
    return this.get(e, null) !== null;
  }
  // Removes an item from local storage
  remove(e) {
    localStorage.removeItem(e);
  }
  // Clears local storage of all items
  clear() {
    localStorage.clear();
  }
  // Returns the number of items in storage
  get length() {
    return localStorage.length;
  }
  // Gets the key of the item at the index specified
  key(e) {
    return localStorage.key(e);
  }
  // gets a value based on the key specified (used when saving objects)
  getObject(e, t = null) {
    let r = this.get(e);
    return r && JSON.parse(r) || t;
  }
}
class ae {
  // sets the value of an item for long term storage
  set(e, t) {
    sessionStorage.setItem(e, t);
  }
  // sets the value of an item for long term storage (used when saving objects)
  setObject(e, t) {
    this.set(e, JSON.stringify(t));
  }
  // gets a value based on the key specified
  get(e, t = "") {
    return sessionStorage.getItem(e) || t;
  }
  // Returns true if the key is present in local storage, false otherwise.
  has(e) {
    return this.get(e, null) !== null;
  }
  // Removes an item from local storage
  remove(e) {
    sessionStorage.removeItem(e);
  }
  // Clears local storage of all items
  clear() {
    sessionStorage.clear();
  }
  // Returns the number of items in storage
  get length() {
    return sessionStorage.length;
  }
  // Gets the key of the item at the index specified
  key(e) {
    return sessionStorage.key(e);
  }
  // gets a value based on the key specified (used when saving objects)
  getObject(e, t = null) {
    let r = this.get(e);
    return r && JSON.parse(r) || t;
  }
}
class B {
  // Creates a new default log output formatter
  // outputFormat: The output format to use when formatting log events (defaults to "{Timestamp}: [{Level}]: {Message}{Exception}")
  // The following placeholders can be used in the output format:
  // {Timestamp}: The timestamp of the log event
  // {Level}: The log level of the log event
  // {Message}: The message of the log event
  // {Exception}: The exception of the log event
  // {PropertyName}: The properties of the log event (where PropertyName is the name of the property)
  constructor(e) {
    this.outputFormat = e ?? "[{Timestamp}]	[{Level}]	{Message}{Exception}";
  }
  // Formats a log event into a string using the output format
  // event: The log event to format into a string
  // Returns the formatted log event
  format(e) {
    return this.outputFormat.replace(/{(\w+)}/g, (t, r) => r === "Timestamp" ? e.timestamp.toISOString() : r === "Level" ? e.level : r === "Message" ? e.message : r === "Exception" ? e.exception ? `
` + e.exception.stack : "" : e.properties[r]);
  }
}
class oe {
  // Creates a new minimum level log filter
  // minimumLevel: The minimum level to write (defaults to "Debug")
  constructor(e = "Debug") {
    this.allowedLevels = ["Verbose", "Debug", "Information", "Warning", "Error", "Fatal"], this.minimumLevel = e, this.allowedLevels = this.allowedLevels.slice(this.allowedLevels.indexOf(e));
  }
  // Filters a log event and returns true if the event should be written to a sink or false if it should be discarded
  // event: The log event to filter
  // Returns true if the event should be written to a sink or false if it should be discarded
  filter(e) {
    return this.allowedLevels.indexOf(e.level) >= 0;
  }
}
class $ {
  constructor() {
    this.styles = {
      Verbose: "color: white;",
      Debug: "color: green",
      Information: "color: blue",
      Warning: "color: yellow",
      Error: "color: red",
      Fatal: "color: palevioletred"
    }, this.consoleMethods = {
      Verbose: (e, t, r) => {
        console.log(e, t, r);
      },
      Debug: (e, t, r) => {
        console.debug(e, t, r);
      },
      Information: (e, t, r) => {
        console.info(e, t, r);
      },
      Warning: (e, t, r) => {
        console.warn(e, t, r);
      },
      Error: (e, t, r) => {
        console.error(e, t, r);
      },
      Fatal: (e, t, r) => {
        console.error(e, t, r);
      }
    };
  }
  // Writes a log event to the console
  // event: The log event to write
  write(e) {
    let t = e.args && typeof e.args != "object", r = e.args && typeof e.args == "object";
    this.consoleMethods[e.level]("%c" + e.message, this.styles[e.level], t ? e.args : ""), r && console.table(e.args);
  }
}
class v {
  // Creates a new log sink pipeline
  // loggerConfiguration: The logger configuration that the pipeline belongs to
  constructor(e) {
    this.filters = [], this.enrichers = [], this.loggerConfiguration = e;
  }
  // Sets the sink that the pipeline writes to
  // sink: The sink to write to
  // Returns the logger configuration that the pipeline belongs to
  writeTo(e) {
    return this.sink = e, this.loggerConfiguration;
  }
  // Adds a filter to the pipeline that filters log events by minimum level (lowest level to write)
  // level: The minimum level to write
  // Returns the pipeline
  minimumLevel(e) {
    return this.filters.push(new oe(e)), this;
  }
  // Adds a filter to the pipeline that filters log events before they are written to the sink
  // filter: The filter to add
  // Returns the pipeline
  filter(e) {
    return this.filters.push(e), this;
  }
  // Sets the formatter that the pipeline uses to format log events before they are written to the sink
  // formatter: The formatter to use
  // Returns the pipeline
  formatUsing(e) {
    return this.formatter = e, this;
  }
  // Adds an enricher to the pipeline that enriches log events before they are written to the sink
  // enricher: The enricher to add
  // Returns the pipeline
  enrichWith(e) {
    return this.enrichers.push(e), this;
  }
  // Processes a log event by filtering, enriching and formatting it before writing it to the sink
  // event: The log event to process
  process(e) {
    this.formatter ?? (this.formatter = new B()), this.sink ?? (this.sink = new $());
    let t = Object.assign({}, e);
    this.filters.some((r) => r.filter(t)) && (this.enrichers.forEach((r) => r.enrich(t)), t.message = this.formatter.format(t) || t.message, this.sink.write(t));
  }
}
class le {
  constructor() {
    this.pipelines = [];
  }
  // Sets the sink that the pipeline writes to
  // sink: The sink to write to
  // Returns the logger configuration that the pipeline belongs to
  writeTo(e) {
    let t = new v(this);
    return this.pipelines.push(t), t.writeTo(e);
  }
  // Adds a filter to the pipeline that filters log events by minimum level (lowest level to write)
  // level: The minimum level to write
  // Returns the pipeline
  minimumLevel(e) {
    let t = new v(this);
    return this.pipelines.push(t), t.minimumLevel(e);
  }
  // Adds a filter to the pipeline that filters log events before they are written to the sink
  // filter: The filter to add
  // Returns the pipeline
  filter(e) {
    let t = new v(this);
    return this.pipelines.push(t), t.filter(e);
  }
  // Sets the formatter that the pipeline uses to format log events before they are written to the sink
  // formatter: The formatter to use
  // Returns the pipeline
  formatUsing(e) {
    let t = new v(this);
    return this.pipelines.push(t), t.formatUsing(e);
  }
  // Adds an enricher to the pipeline that enriches log events before they are written to the sink
  // enricher: The enricher to add
  // Returns the pipeline
  enrichWith(e) {
    let t = new v(this);
    return this.pipelines.push(t), t.enrichWith(e);
  }
  // Writes a log event to the configured sinks after processing it with the configured pipelines
  // level: The level of the log event
  // message: The message of the log event
  // properties: The properties of the log event
  // exception: The exception of the log event
  write(e, t, r, s) {
    let n = {
      level: e,
      message: t,
      properties: {},
      exception: s,
      timestamp: /* @__PURE__ */ new Date(),
      args: r
    };
    this.pipelines.forEach((a) => a.process(n));
  }
}
class he {
  // Enriches a log event with the current URL
  // event: The log event to enrich
  enrich(e) {
    e.properties ?? (e.properties = {}), e.properties.url = window.location.href;
  }
}
class ce {
  // Enriches a log event with the caller
  // event: The log event to enrich
  enrich(e) {
    e.properties ?? (e.properties = {});
    let t = this.matchAll(new Error().stack.toString(), /at([\s\w\d\.$]+)[\(]?((http|https|ftp)[^\)\n]+)[\)]?/gi).map((r) => r[2].trim());
    e.properties.caller = t[t.length - 1];
  }
  // Matches all occurrences of a regular expression in a string
  matchAll(e, t) {
    const r = t.global ? t.flags : t.flags + "g", s = new RegExp(t, r);
    let n = [], a;
    for (; a = s.exec(e); )
      n.push(a);
    return n;
  }
}
class h {
  // Hides the constructor
  constructor() {
  }
  // Gets the logger configuration that the logger uses to configure its sinks, filters, formatters and enrichers
  static configure() {
    return this.loggerConfiguration ?? (this.loggerConfiguration = window.LoggerConfiguration || new le()), window.LoggerConfiguration = this.loggerConfiguration, this.loggerConfiguration;
  }
  // Writes a log event to the logger
  // level: The level of the log event
  // message: The message of the log event
  // properties: The properties of the log event
  // exception: The exception of the log event
  static write(e, t, r, s) {
    h.configure().write(e, t, r, s);
  }
  // Writes a log event to the logger with the Verbose level
  // message: The message of the log event
  // properties: The properties of the log event
  static verbose(e, t) {
    this.write("Verbose", e, t);
  }
  // Writes a log event to the logger with the Debug level
  // message: The message of the log event
  // properties: The properties of the log event
  static debug(e, t) {
    this.write("Debug", e, t);
  }
  // Writes a log event to the logger with the Information level
  // message: The message of the log event
  // properties: The properties of the log event
  static information(e, t) {
    this.write("Information", e, t);
  }
  // Writes a log event to the logger with the Warning level
  // message: The message of the log event
  // properties: The properties of the log event
  static warning(e, t) {
    this.write("Warning", e, t);
  }
  // Writes a log event to the logger with the Error level
  // message: The message of the log event
  // properties: The properties of the log event
  // exception: The exception of the log event
  static error(e, t, r) {
    this.write("Error", e, t, r);
  }
  // Writes a log event to the logger with the Fatal level
  // message: The message of the log event
  // properties: The properties of the log event
  // exception: The exception of the log event
  static fatal(e, t, r) {
    this.write("Fatal", e, t, r);
  }
}
class ue {
  // Constructor
  // dbName: The name of the database
  // tables: The tables to create
  // version: The version of the database
  constructor(e, t, r) {
    this.dbName = e, this.tables = t, this.version = r;
    const s = indexedDB.open(e, r);
    s.onupgradeneeded = (n) => {
      this.database = n.target.result;
      for (const a of t)
        this.database.objectStoreNames.contains(a) && this.database.deleteObjectStore(a), this.database.createObjectStore(a);
    }, s.onsuccess = (n) => {
      this.database = n.target.result;
    }, s.onerror = (n) => {
      h.error("Failed to open the database:", n.target.error);
    };
  }
  // Opens the database connection
  openDatabase() {
    return new Promise((e, t) => {
      const r = indexedDB.open(this.dbName, this.version);
      r.onsuccess = (s) => {
        this.database = s.target.result, e(this);
      }, r.onerror = (s) => {
        h.error("Failed to open the database:", s.target.error), t(new Error("Failed to open the database:" + s.target.error));
      };
    });
  }
  // Adds an object to the database
  // table: The table to add the object to
  // obj: The object to add
  // key: The key to add the object with
  add(e, t, r) {
    return new Promise((s, n) => {
      const l = this.database.transaction(e, "readwrite").objectStore(e).put(t, r);
      l.onsuccess = () => {
        s();
      }, l.onerror = (c) => {
        h.error("Failed to add an object to the database: ", c.target.error), n(new Error("Failed to add an object to the database: " + c.target.error));
      };
    });
  }
  // Removes an object from the database
  // table: The table to remove the object from
  // key: The key of the object to remove
  remove(e, t) {
    return new Promise((r, s) => {
      const o = this.database.transaction(e, "readwrite").objectStore(e).delete(t);
      o.onsuccess = () => {
        r();
      }, o.onerror = (l) => {
        h.error("Failed to remove an object from the database: ", l.target.error), s(new Error("Failed to remove an object from the database: " + l.target.error));
      };
    });
  }
  // Gets an object from the database by key
  // table: The table to get the object from
  // key: The key of the object to get
  getByKey(e, t) {
    return new Promise((r, s) => {
      const o = this.database.transaction(e, "readwrite").objectStore(e).get(t);
      o.onsuccess = (l) => {
        r(l.target.result);
      }, o.onerror = (l) => {
        h.error("Failed to retrieve an object from the database: ", l.target.error), s(new Error("Failed to retrieve an object from the database: " + l.target.error));
      };
    });
  }
  // Gets all objects from the database
  // table: The table to get the objects from
  // query: The query to filter the objects by
  getKeys(e) {
    return new Promise((t, r) => {
      const a = this.database.transaction(e, "readwrite").objectStore(e).getAllKeys();
      a.onsuccess = (o) => {
        t(o.target.result);
      }, a.onerror = (o) => {
        h.error("Failed to retrieve an object from the database: ", o.target.error), r(new Error("Failed to retrieve keys from the database: " + o.target.error));
      };
    });
  }
  // Gets an object from the database by key
  // table: The table to get the object from
  // query: The query to filter the objects by
  get(e, t) {
    return new Promise((r, s) => {
      const o = this.database.transaction(e, "readwrite").objectStore(e).get(t);
      o.onsuccess = (l) => {
        r(l.target.result);
      }, o.onerror = (l) => {
        h.error("Failed to retrieve an object from the database: ", l.target.error), s(new Error("Failed to retrieve an object from the database: " + l.target.error));
      };
    });
  }
  // Gets all objects from the database
  // table: The table to get the objects from
  // query: The query to filter the objects by
  getAll(e, t) {
    return new Promise((r, s) => {
      const o = this.database.transaction(e, "readwrite").objectStore(e).getAll(t);
      o.onsuccess = (l) => {
        r(l.target.result);
      }, o.onerror = (l) => {
        h.error("Failed to retrieve an object from the database: ", l.target.error), s(new Error("Failed to retrieve objects from the database: " + l.target.error));
      };
    });
  }
}
class M {
  // Constructor
  constructor() {
    this.database = new ue("cacheStore", ["cache", "cacheEntryOptions"], 1);
  }
  // Clears the database of all items and options
  // Returns a promise that resolves when the operation is complete
  async clear() {
    await this.database.openDatabase();
    let e = await this.database.getAll("cacheEntryOptions"), t = await this.database.getAll("cache");
    for (let r = 0; r < e.length; r++) {
      let s = t[r];
      await this.remove(s.key);
    }
    return this;
  }
  // Gets the options for an object in the database by key
  // key: The key of the object to get the options for
  // Returns a promise that resolves with the options
  async getOptions(e) {
    return await this.database.openDatabase(), this.database.getByKey("cacheEntryOptions", e);
  }
  // Adds an object to the database
  // obj: The object to add
  // key: The key to add the object with
  // options: The options to add the object with
  async add(e, t, r) {
    return await this.database.openDatabase(), await this.database.add("cache", e, t), await this.database.add("cacheEntryOptions", r, t), this;
  }
  // Removes an object from the database
  // key: The key of the object to remove
  async remove(e) {
    return await this.database.openDatabase(), await this.database.remove("cache", e), await this.database.remove("cacheEntryOptions", e), this;
  }
  // Gets an object from the database by key
  // table: The table to get the object from
  // key: The key of the object to get
  async get(e) {
    return await this.database.openDatabase(), this.database.getByKey("cache", e);
  }
  // Compacts the database. This is used to remove expired items from the database.
  // This method is called automatically by the cache.
  // Returns a promise that resolves when the operation is complete
  async compact() {
    await this.database.openDatabase();
    let e = await this.database.getAll("cacheEntryOptions"), t = await this.database.getAll("cache"), r = (/* @__PURE__ */ new Date()).getTime();
    for (let s = 0; s < e.length; s++) {
      let n = e[s], a = t[s];
      n.expirationTime != 0 && n.expirationTime < r && await this.remove(a.key);
    }
    return this;
  }
}
class F {
  // Hides the constructor
  constructor() {
  }
  // Configures the cache with the specified storage provider
  // storageProvider: The storage provider to use for the cache
  static configure(e = new M()) {
    this.storageProvider ?? (this.storageProvider = window.StorageProvider || new M()), window.StorageProvider = this.storageProvider;
  }
  // Sets an object in the cache by key with the specified options
  // key: The key to set the object with
  // value: The value to set the object with
  // entryOptions: The options to set the object with
  // Returns a promise that resolves when the operation is complete
  static async set(e, t, r = { expirationTime: 0, slidingExpirationTime: 0, sliding: !1 }) {
    h.debug("Setting object in cache: ", { key: e, value: t, entryOptions: r }), this.configure(), await this.storageProvider.add(t, e, r);
  }
  // Gets an object from the cache by key and resets the expiration time if the object is set to sliding expiration
  // key: The key of the object to get
  // Returns a promise that resolves with the object
  static async get(e) {
    h.debug("Getting object from cache: " + e), this.configure(), await this.storageProvider.compact();
    let t = await this.storageProvider.get(e);
    if (t == null)
      return t;
    let r = await this.storageProvider.getOptions(e);
    return r.sliding && await this.set(e, t, {
      expirationTime: (/* @__PURE__ */ new Date()).getTime() + r.slidingExpirationTime,
      slidingExpirationTime: r.slidingExpirationTime,
      sliding: !0
    }), t;
  }
  // Removes an object from the cache by key
  // key: The key of the object to remove
  // Returns a promise that resolves when the operation is complete
  static async remove(e) {
    h.debug("Removing object from cache: " + e), this.configure(), await this.storageProvider.remove(e);
  }
  // Clears the cache of all items
  // Returns a promise that resolves when the operation is complete
  static async clear() {
    h.debug("Clearing cache"), this.configure(), await this.storageProvider.clear();
  }
}
class w {
  // Constructor
  // options: The request options
  constructor(e) {
    this.options = {
      method: "GET",
      url: "",
      headers: {},
      credentials: "same-origin",
      serializer: JSON.stringify,
      parser: (t) => t.json(),
      success: (t) => {
        h.debug("Request response from " + this.options.url + ":", t);
      },
      error: (t) => {
        h.error("Request error from " + this.options.url + ":", t);
      },
      retry: (t) => {
        h.debug("Request retry on " + this.options.url + ":", { attempt: t });
      },
      storageMode: 0,
      cacheKey: "",
      timeout: 6e4,
      retryAttempts: 3,
      retryDelay: 1e3
    }, this.abortController = null, this.options = { ...this.options, ...e };
  }
  // Creates a GET request
  // Note: GET requests are cached by default
  // url: The request url
  // data: The request data
  static get(e, t) {
    return new w({ method: "GET", url: e, data: t, cacheKey: e + JSON.stringify(t) }).withHeaders({
      Accept: "application/json"
    });
  }
  // Creates a POST request
  // Note: POST requests are not cached by default
  // url: The request url
  // data: The request data
  static post(e, t) {
    return new w({
      method: "POST",
      url: e,
      data: t,
      cacheKey: e + JSON.stringify(t),
      storageMode: 2
      /* NetworkOnly */
    }).withHeaders({
      "Content-Type": "application/json",
      Accept: "application/json"
    });
  }
  // Creates a PUT request
  // Note: PUT requests are not cached by default
  // url: The request url
  // data: The request data
  static put(e, t) {
    return new w({
      method: "PUT",
      url: e,
      data: t,
      cacheKey: e + JSON.stringify(t),
      storageMode: 2
      /* NetworkOnly */
    }).withHeaders({
      "Content-Type": "application/json",
      Accept: "application/json"
    });
  }
  // Creates a DELETE request
  // Note: DELETE requests are not cached by default
  // url: The request url
  // data: The request data
  static delete(e, t) {
    return new w({
      method: "DELETE",
      url: e,
      data: t,
      cacheKey: e + JSON.stringify(t),
      storageMode: 2
      /* NetworkOnly */
    }).withHeaders({
      Accept: "application/json"
    });
  }
  // Creates a request of the specified type (e.g. GET, POST, PUT, DELETE, etc.)
  // method: The request method
  // url: The request url
  // data: The request data
  static ofType(e, t, r) {
    return new w({ method: e, url: t, data: r, cacheKey: t + JSON.stringify(r) }).withHeaders({
      Accept: "application/json"
    });
  }
  // Adds an authentication provider to the request (used to authenticate the request)
  // authenticationProvider: The authentication provider
  withAuthenticationProvider(e) {
    return this.options.authenticationProvider = e, this;
  }
  // Adds header values to the request
  // headers: The header values
  withHeaders(e) {
    return this.options.headers = { ...this.options.headers, ...e }, this;
  }
  // Adds a cancellation token to the request (used to cancel the request)
  // cancellationToken: The cancellation token
  // Note: The request will finish executing, but the success/error callbacks will not be called if the request is cancelled.
  withCancellationToken(e) {
    return this.options.cancellationToken = e, this;
  }
  // Adds credentials to the request
  // credentials: The credentials
  withCredentials(e) {
    return this.options.credentials = e, this;
  }
  // Sets the serializer for the request
  // serializer: The serializer
  withSerializer(e) {
    return this.options.serializer = e, this;
  }
  // Sets the parser for the request
  // parser: The parser
  withParser(e) {
    return this.options.parser = e, this;
  }
  // Sets the success callback for the request
  // callback: The success callback
  onSuccess(e) {
    return this.options.success = e ?? ((t) => {
      h.debug("Request response:", t);
    }), this;
  }
  // Sets the error callback for the request
  // callback: The error callback
  onError(e) {
    return this.options.error = e ?? ((t) => {
      h.error("Request error:", t);
    }), this;
  }
  // Sets the retry callback for the request
  // callback: The retry callback
  onRetry(e) {
    return this.options.retry = e ?? ((t) => {
      h.debug("Request retry:", { attempt: t });
    }), this;
  }
  // Sets the storage mode for the request
  // storageMode: The storage mode
  withStorageMode(e) {
    return this.options.storageMode = e, this;
  }
  // Sets the cache key for the request
  // cacheKey: The cache key
  withCacheKey(e) {
    return this.options.cacheKey = e, this;
  }
  // Sets the timeout for the request
  // timeout: The timeout in milliseconds (default: 60000)
  // Note: The timeout is only used for network requests
  withTimeout(e) {
    return this.options.timeout = e ?? 6e4, this;
  }
  // Sets the number of retry attempts for the request
  // retryAttempts: The number of retry attempts (default: 3)
  // Note: The retry attempts are only used for network requests
  withRetryAttempts(e) {
    return this.options.retryAttempts = e, this;
  }
  // Sets the retry delay for the request in milliseconds
  // retryDelay: The retry delay in milliseconds (default: 1000)
  // Note: The retry delay is only used for network requests
  withRetryDelay(e) {
    return this.options.retryDelay = e, this;
  }
  // Aborts the request, if it is still running, and calls the error callback.
  // Note: This is only supported for network requests
  abort() {
    return this.abortController === null ? this : (this.abortController.abort(), this.options.error(new Error("The request was aborted.")), this);
  }
  // Actually sends the request, parses it, and calls either the
  // success or error functions if they exist.
  // Returns the parsed response.
  async send() {
    const { authenticationProvider: e, method: t, url: r, data: s, headers: n, credentials: a, serializer: o, parser: l, success: c, error: p, storageMode: u, cacheKey: m, timeout: k, retryAttempts: J, retryDelay: Y, retry: Q, cancellationToken: A } = this.options, O = new AbortController();
    this.abortController = O;
    let T = 0, P = null;
    const x = async () => {
      if (u === 1 || u === 3) {
        const g = await F.get(m);
        if (g !== void 0 && (c(g), u === 1))
          return g;
      }
      if (!navigator.onLine) {
        if (u === 0) {
          const d = await F.get(m);
          if (d !== void 0)
            return c(d), d;
        }
        const g = new Error("System is offline");
        return p(g), Promise.reject(g);
      }
      try {
        const g = o(s);
        await (e == null ? void 0 : e.authenticate(this));
        const d = await Promise.race([
          fetch(r, {
            method: t,
            credentials: a,
            headers: n,
            body: g,
            signal: O.signal
          }),
          this.handleTimeout(k)
        ]);
        if (A != null && A.canceled)
          return Promise.reject(new Error("The request was canceled."));
        if (d.status >= 200 && d.status < 300) {
          const j = await l(d);
          return c(j), u !== 2 && await F.set(m, j), j;
        }
        P = new Error(d.statusText), d.status === 401 && await (e == null ? void 0 : e.authenticationFailed(this, d));
      } catch (g) {
        P = g;
      }
      return T < J ? (++T, await new Promise((g) => setTimeout(g, Y)), Q(T), x()) : (p(P), Promise.reject(P));
    };
    return x();
  }
  // Handles the timeout for the request
  // timeout: The timeout in milliseconds (default: 60000)
  // returns: A promise that rejects when the timeout is reached
  async handleTimeout(e) {
    throw e ?? (e = 6e4), await new Promise((t, r) => {
      setTimeout(() => {
        r(new Error("Request timeout"));
      }, e);
    }), new Error("Request timeout");
  }
}
var z = /* @__PURE__ */ ((i) => (i[i.NetworkFirst = 0] = "NetworkFirst", i[i.StorageFirst = 1] = "StorageFirst", i[i.NetworkOnly = 2] = "NetworkOnly", i[i.StorageAndUpdate = 3] = "StorageAndUpdate", i))(z || {});
class C {
  // Returns the current domain.
  static get domain() {
    return window.location.protocol + "//" + window.location.host + "/";
  }
  // Determines if this is being run locally or in production.
  static get isLocal() {
    return /^http:\/\/localhost:\d{5}\/$/.test(C.domain);
  }
  // Gets the hash without the hash bang.
  static get HashBang() {
    return window.location.hash.replace("#!", "");
  }
  // Gets the text after the last slash. Presumably the ID needed.
  static get Id() {
    return window.location.pathname.substring(window.location.pathname.lastIndexOf("/") + 1);
  }
  // Gets a value from the query string.
  static GetQueryString(e) {
    let t = window.location.href;
    var r = new RegExp("[?&]" + e + "=([^&#]*)", "i"), s = r.exec(t);
    return s ? s[1] : null;
  }
  // Sets the title for the page.
  static setPageTitle(e) {
    document.title = e;
  }
}
const L = class L {
};
L.keyMappings = {
  BACKSPACE: 8,
  TAB: 9,
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  PAUSE: 19,
  CAPSLOCK: 20,
  ESCAPE: 27,
  SPACE: 32,
  PAGEUP: 33,
  PAGEDOWN: 34,
  END: 35,
  HOME: 36,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  INS: 45,
  DEL: 46,
  META: 91,
  "*": 106,
  "+": 107,
  MINUS: 109,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  NUMLOCK: 144,
  SCROLLLOCK: 145,
  ";": 186,
  "=": 187,
  "": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
let y = L;
class ge {
  // Constructor
  constructor(e) {
    this.keys = this.getKeys(e);
  }
  // gets the key codes for the string passed in
  getKeys(e) {
    return e.toUpperCase().split(/-(?!$)/).map((t) => y.keyMappings[t] || t.charCodeAt(0));
  }
  // determines if the key code is pressed
  isPressed(e) {
    let t = e;
    if (t.length !== this.keys.length)
      return !1;
    for (let r = 0; r < t.length; ++r)
      if (this.keys.indexOf(t[r]) === -1)
        return !1;
    return !0;
  }
}
class pe {
  // constructor
  constructor(e, t) {
    this.keyCodeSequence = e.toUpperCase(), this.keyCodes = e.toUpperCase().split(" ").map((r) => new ge(r)), this.callback = t, this.length = this.keyCodes.length, this.isDefault = e === "<*>";
  }
  // calls the callback function with the data specified
  call(e, t, r) {
    return this.callback(t, { scope: r, keysPressed: e }), !0;
  }
  // Runs the callback based on the keycode being pressed
  press(e, t, r) {
    let s = e;
    if (s.length !== this.length)
      return !1;
    for (let n = 0; n < this.keyCodes.length; ++n)
      if (!this.keyCodes[n].isPressed(s[n]))
        return !1;
    return this.call(e, t, r);
  }
  // determines if this is a partial match on a sequence
  isPartial(e) {
    let t = e;
    if (t.length > this.length)
      return !1;
    for (let r = 0; r < t.length; ++r)
      if (!this.keyCodes[r].isPressed(t[r]))
        return !1;
    return !0;
  }
}
class E {
  // constructor
  constructor(e) {
    this.name = e, this.sequences = [];
  }
  // determines if anything in this scope was pressed
  press(e, t) {
    this.sequences = this.sequences.sort((r, s) => r.length > s.length ? 1 : -1);
    for (let r = 0; r < this.sequences.length; ++r)
      if (this.sequences[r].press(e, t, this))
        return !0;
    return !1;
  }
  // calls the default handler if one exists
  callDefault(e, t) {
    let r = this.sequences.filter((s) => s.isDefault);
    return r.length === 0 ? !1 : r[0].call(e, t, this);
  }
  // determines if the sequence is a partial match
  isPartial(e) {
    for (let t = 0; t < this.sequences.length; ++t)
      if (this.sequences[t].isPartial(e))
        return !0;
    return !1;
  }
  // adds an individual sequence to the scope
  addSequence(e, t) {
    return this.removeSequence(e), this.sequences.push(new pe(e, t)), this;
  }
  // removes an individual sequence from the scope
  removeSequence(e) {
    return this.sequences = this.sequences.filter((t) => t.keyCodeSequence !== e.toUpperCase()), this;
  }
  // clears the sequences and scopes from the scope
  clear() {
    return this.sequences = [], this;
  }
}
class de {
  // constructor
  constructor() {
    this.scopes = {}, this.scopes.Default = new E("Default"), this.currentScope = this.scopes.Default, this.filter = (e) => {
      let t = (e.target || e.srcElement).tagName;
      return t !== "INPUT" && t !== "SELECT" && t !== "TEXTAREA";
    }, this.latestKeys = [];
  }
  // Sets the current scope, adding it if it doesn't exist and returns it.
  setScope(e) {
    let t = this.addScope(e);
    return this.currentScope = t, t;
  }
  // Adds a scope to the system and returns it (or returns it if it already exists)
  addScope(e) {
    let t = this.scopes[e];
    return t !== void 0 || (t = new E(e), this.scopes[e] = t), t;
  }
  // Removes a scope from the system
  removeScope(e) {
    return this.scopes[e] = void 0, e === "Default" && (this.scopes.Default = new E("Default")), this.currentScope.name === e && (this.currentScope = this.scopes.Default), this;
  }
  // clears all scopes and creates a new Default scope
  clear() {
    return this.scopes = {}, this.scopes.Default = new E("Default"), this.currentScope = this.scopes.Default, this.latestKeys = [], this;
  }
  // adds a sequence to the current scope
  bind(e, t) {
    return this.currentScope.addSequence(e, t), this;
  }
  // removes a sequence from the current scope
  unbind(e) {
    return this.currentScope.removeSequence(e), this;
  }
  // Called when a press event is fired
  press(e) {
    if (!this.filter(e))
      return;
    let t = this.getKeys(e);
    this.latestKeys.push(t);
    let r = this.latestKeys.slice();
    if (this.currentScope.press(this.latestKeys, e))
      this.latestKeys = [];
    else {
      for (; this.latestKeys.length > 0; ) {
        if (this.currentScope.isPartial(this.latestKeys))
          return;
        this.latestKeys.shift();
      }
      this.latestKeys.length === 0 && this.currentScope.callDefault(r, e);
    }
  }
  // gets the string version of the keys currently pressed
  getKeys(e) {
    let t = [];
    return e.altKey && t.push(y.keyMappings.ALT), e.ctrlKey && t.push(y.keyMappings.CTRL), e.metaKey && t.push(y.keyMappings.META), e.shiftKey && t.push(y.keyMappings.SHIFT), t.indexOf(e.keyCode) === -1 && t.push(e.keyCode), t;
  }
}
class U {
}
class fe {
  //Constructor
  constructor(e, t) {
    this.variable = e.charAt(0) === "{" && e.charAt(e.length - 1) === "}", e = e.replace(/[{}]/g, ""), this.optional = e.charAt(0) === "^", this.part = e.replace(/[\^]/g, ""), t[this.part] !== void 0 ? this.defaultValue = t[this.part] : this.defaultValue = "";
  }
  //Determines if this is a match.
  isMatch(e) {
    return e == null ? this.optional : (e = e, this.variable ? this.optional || e !== "" : this.optional || e.toUpperCase() === this.part.toUpperCase());
  }
  //Gets the value, if it is a variable. If it is not a variable, it returns undefined and if it is a variable but no
  //value is present it returns null.
  getValue(e) {
    return this.variable ? e !== void 0 ? e || this.defaultValue : this.defaultValue : e || this.defaultValue;
  }
  //Sets the value used for the path part
  setValue(e, t) {
    this.getValue(e), t[this.part] = this.getValue(e);
  }
}
class me {
  // Constructor
  constructor(e, t) {
    let r = e.split("=", 2);
    this.key = r[0], e = r[1], this.variable = e.charAt(0) === "{" && e.charAt(e.length - 1) === "}", e = e.replace(/[{}]/g, ""), this.optional = e.charAt(0) === "^", this.part = e.replace(/[\^]/g, ""), t[this.part] !== void 0 ? this.defaultValue = t[this.part] : this.defaultValue = "";
  }
  // Determines if this is a match.
  isMatch(e) {
    if (e == null)
      return !1;
    let t = e.split("=", 2);
    return t.length !== 2 || this.key.toUpperCase() !== t[0].toUpperCase() ? !1 : (e = t[1], e === void 0 ? this.optional : this.variable ? this.optional || e !== "" : this.optional || e.toUpperCase() === this.part.toUpperCase());
  }
  // Gets the value, if it is a variable. If it is not a variable, it returns undefined and if it is a variable but no
  // value is present it returns null.
  getValue(e) {
    if (e == null)
      return this.defaultValue;
    let t = e.split("=", 2);
    return t.length !== 2 ? this.defaultValue : (e = t[1], this.variable ? e !== void 0 ? e || this.defaultValue : this.defaultValue : e || this.defaultValue);
  }
  // Sets the value used for the path part
  setValue(e, t) {
    this.getValue(e), t[this.key] = this.getValue(e);
  }
}
class we {
  // Constructor
  constructor(e, t) {
    e = e.replace(/[#!]/g, ""), this.variable = e.charAt(0) === "{" && e.charAt(e.length - 1) === "}", e = e.replace(/[{}]/g, ""), this.optional = e.charAt(0) === "^", this.part = e.replace(/[\^]/g, ""), t[this.part] !== void 0 ? this.defaultValue = t[this.part] : this.defaultValue = "";
  }
  // Determines if this is a match.
  isMatch(e) {
    return e == null ? this.optional : (e = e.replace(/[#!]/g, ""), this.variable ? this.optional || e !== "" : this.optional || e.toUpperCase() === this.part.toUpperCase());
  }
  // Gets the value, if it is a variable. If it is not a variable, it returns undefined and if it is a variable but no
  // value is present it returns null.
  getValue(e) {
    return this.variable ? e !== void 0 ? e || this.defaultValue : this.defaultValue : e || this.defaultValue;
  }
  // Sets the value used for the path part
  setValue(e, t) {
    e = e || "", e = e.replace(/[#!]/g, ""), t[this.part] = this.getValue(e);
  }
}
class ye {
  // Constructor
  constructor(e, t, r) {
    r === void 0 && (r = new U()), this.url = this.fixUrl(e), this.pathParts = this.getPathParts(this.url).map((s) => new fe(s, r)), this.pathParts = this.pathParts ? this.pathParts : [], this.queryParts = this.getQueryParts(this.url).map((s) => new me(s, r)), this.queryParts = this.queryParts ? this.queryParts : [], this.hashParts = this.getHashParts(this.url).map((s) => new we(s, r)), this.hashParts = this.hashParts ? this.hashParts : [], this.callbacks = [t], this.defaultValues = r;
  }
  // Determines if the url passed in equals the current route
  isRoute(e) {
    return this.url === this.fixUrl(e);
  }
  // adds a callback to the route
  addCallback(e) {
    this.callbacks.push(e);
  }
  // removes a callback from the route
  removeCallback(e) {
    this.callbacks = this.callbacks.filter((t) => t !== e);
  }
  // Fixes a url that is passed in
  fixUrl(e) {
    return e.length ? e.replace(/^\//, "").replace(/\/+/g, "/").replace(/^\/|\/($|\?)/, "").replace(/\/\#/g, "#") : e;
  }
  // Get the path parts for the route
  getPathParts(e) {
    return e.split("?", 2)[0].split("#", 2)[0].split("/");
  }
  // Gets the hash code portion of the url
  getHashParts(e) {
    let t = e.split("?", 2)[0].split("#", 2);
    return t.length < 2 ? [] : [t[1].replace("!", "")];
  }
  // Gets the query string parts of the url
  getQueryParts(e) {
    let t = e.split("?", 2);
    return t.length < 2 ? [] : (e = t[1], e ? e.split("&") : []);
  }
  // Gets the parameters from the url specified
  getParametersFromUrl(e, t, r) {
    let s = new U();
    for (let n = 0; n < e.length; ++n)
      this.pathParts[n].setValue(e[n], s);
    for (let n = 0; n < t.length; ++n)
      this.queryParts[n].setValue(t[n], s);
    for (let n = 0; n < r.length; ++n)
      this.hashParts[n].setValue(r[n], s);
    if (this.pathParts.length > e.length)
      for (let n = e.length; n < this.pathParts.length; ++n)
        this.pathParts[n].setValue("", s);
    if (this.queryParts.length > t.length)
      for (let n = t.length; n < this.queryParts.length; ++n)
        this.queryParts[n].setValue("", s);
    if (this.hashParts.length > r.length)
      for (let n = r.length; n < this.hashParts.length; ++n)
        this.hashParts[n].setValue("", s);
    return s;
  }
  // Determines if the route is a match
  isMatch(e, t, r) {
    if (this.pathParts.length < e.length)
      return !1;
    for (let s = 0; s < e.length; ++s)
      if (!this.pathParts[s].isMatch(e[s]))
        return !1;
    if (this.pathParts.length > e.length) {
      for (let s = e.length; s < this.pathParts.length; ++s)
        if (!this.pathParts[s].isMatch(""))
          return !1;
    }
    if (this.queryParts.length < t.length)
      return !1;
    for (let s = 0; s < t.length; ++s)
      if (!this.queryParts[s].isMatch(t[s]))
        return !1;
    if (this.queryParts.length > t.length) {
      for (let s = t.length; s < this.queryParts.length; ++s)
        if (!this.queryParts[s].isMatch(""))
          return !1;
    }
    if (this.hashParts.length < r.length)
      return !1;
    for (let s = 0; s < r.length; ++s)
      if (!this.hashParts[s].isMatch(r[s]))
        return !1;
    if (this.hashParts.length > r.length) {
      for (let s = r.length; s < this.hashParts.length; ++s)
        if (!this.hashParts[s].isMatch(""))
          return !1;
    }
    return !0;
  }
  // Calls the route's callback function
  run(e) {
    e = this.fixUrl(e);
    let t = this.getPathParts(e), r = this.getQueryParts(e), s = this.getHashParts(e);
    if (!this.isMatch(t, r, s))
      return !1;
    let n = this.getParametersFromUrl(t, r, s);
    return n.url = e, this.callbacks.forEach((a) => a(n)), !0;
  }
}
class be {
  // Constructor
  constructor() {
    this.routes = [];
  }
  // Maps a set of routes to the action specified
  map(e) {
    for (let t = 0; t < e.length; ++t)
      this.addRoute(e[t].url, e[t].action, e[t].defaultValues);
  }
  // Adds a route to the router
  addRoute(e, t, r) {
    let s = this.routes.filter((n) => n.isRoute(e));
    return s.length === 0 ? this.routes.push(new ye(e, t, r)) : s[0].addCallback(t), this;
  }
  // Runs the url specified and returns true if it ran successfully, false otherwise.
  run(e) {
    for (let t = 0; t < this.routes.length; ++t)
      if (this.routes[t].run(e))
        return !0;
    return !1;
  }
}
class Se {
  // Goes back by the value specified
  back(e) {
    e === void 0 && (e = 1), window.history.go(-1 * e);
  }
  // Goes forward by the value specified
  forward(e) {
    e === void 0 && (e = 1), window.history.go(e);
  }
  // pushes a new url/state onto the history
  push(e, t, r) {
    window.history.pushState(e, r, t);
  }
  // replaces the current url with a new url/state
  replace(e, t, r) {
    window.history.replaceState(e, r, t);
  }
  // gets the current state
  get state() {
    return window.history.state;
  }
  // Returns the number of items in storage
  get length() {
    return window.history.length;
  }
}
class Ne {
  // Exports the array of entries to the file specified
  static exportData(e, t, r = C.Id, s = 0) {
    if (e.length == 0)
      return;
    r = r || C.Id;
    let n = "";
    s === 0 ? n = this.exportCSV(e, t, r) : n = e.join(","), this.download(n, r);
  }
  // Capitalizes a string's first character
  static capitalize(e) {
    return e ? e.charAt(0).toUpperCase() + e.slice(1) : "";
  }
  // Exports a CSV of the data
  static exportCSV(e, t, r) {
    var o, l;
    let s = "", n = Object.keys(e[0]), a = "";
    for (let c = 0; c < n.length; ++c) {
      let p = n[c], u = t.filter(function(k) {
        return k.property === p;
      });
      u.length === 0 && (u = [{ display: p, property: p }]);
      let m = ((o = u[0]) == null ? void 0 : o.display) || ((l = u[0]) == null ? void 0 : l.property) || p;
      s += a + '"' + this.capitalize(m) + '"', a = ",";
    }
    s += `
`;
    for (let c = 0; c < e.length; ++c) {
      let p = e[c], u = Object.keys(p);
      a = "";
      for (let m = 0; m < u.length; ++m)
        s += a + '"' + p[u[m]].replaceAll('"', "'") + '"', a = ",";
      s += `
`;
    }
    return s;
  }
  // Downloads the data as the file specified
  static download(e, t) {
    if (e != null) {
      if (navigator.msSaveBlob) {
        navigator.msSaveBlob(new Blob([e]), t);
        return;
      }
      var r = document.createElement("a");
      r.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(e)), r.setAttribute("download", t), r.style.display = "none", document.body.appendChild(r), r.click(), document.body.removeChild(r);
    }
  }
}
class ve {
  // constructor
  constructor() {
    h.configure().minimumLevel("Debug").enrichWith(new ce()).enrichWith(new he()).formatUsing(new B("[{Timestamp}]	[{Level}]	[{caller}]		{Message}{Exception}")).writeTo(new $()), this.localStorage = new ne(), this.sessionStorage = new ae(), this.hotkeys = new de(), this.router = new be(), this.history = new Se(), window.addEventListener("keydown", (e) => this.hotkeys.press(e)), window.onerror = (e, t, r, s, n) => {
      h.error(e.toString(), { url: t, line: r, column: s, stack: (n == null ? void 0 : n.stack) || "" }, n);
    };
  }
}
let f = {
  mounted: function(i, e) {
    if (f.onEventBound = f.onEvent.bind({ el: i }), document.addEventListener("click", f.onEventBound), typeof e.value != "function")
      throw new Error("Argument must be a function");
    f.cb = e.value;
  },
  cb: function(i) {
  },
  onEvent: function(i) {
    i.target === this.el || this.el.contains(i.target) || !f.cb || f.cb(i);
  },
  onEventBound: function() {
  },
  unbind: function() {
    document.removeEventListener("click", f.onEventBound);
  },
  update: function(i, e) {
    if (typeof e.value != "function")
      throw new Error("Argument must be a function");
    f.cb = e.value;
  }
};
function De(i) {
  return i.directive("click-outside", f), i;
}
function Pe(i) {
  return i == null || (i.config.globalProperties.$filters = {
    moment: function(e, t, r) {
      return e == null ? "N/A" : (r ?? (r = "YYYY-MM-DDThh:mm:ss"), t ?? (t = "M-D-YYYY h:mm A"), X(e, r).format(t));
    },
    capitalize: function(e) {
      return e == null ? "" : e.charAt(0).toUpperCase() + e.slice(1);
    },
    maxsize: function(e, t, r) {
      return e == null ? "" : e.length <= t ? e : (r ?? (r = "..."), e.substring(0, t) + r);
    },
    currency: function(e, t, r) {
      return e == null ? "" : (t ?? (t = "en-US"), r ?? (r = { style: "currency", currency: "USD" }), Intl.NumberFormat(t, r).format(e));
    }
  }), i;
}
class K {
}
String.prototype.slugify = function() {
  return this.trim().replace(/ /g, "-").replace(/-{2,}/g, "-").replace(/^-+|-+$/g, "").replace(/([^a-zA-Z0-9-_/./:]+)/g, "");
};
String.prototype.stripHTML = function() {
  let i = document.createElement("div");
  return i.innerHTML = this, (i.textContent || i.innerText || "").replace(/^\s+|\s+$/g, "");
};
String.prototype.toNumber = function() {
  return this == null ? 0 : parseFloat(this.stripHTML().replace(/[^0-9.-]/g, ""));
};
const Ee = I.defineComponent({
  name: "DataHandler",
  data: function() {
    return {
      count: 0,
      timer: 0,
      internalData: this.model
    };
  },
  props: {
    model: {
      type: Object,
      default: {}
    },
    schema: {
      type: K,
      default: new K()
    }
  },
  methods: {
    fetchData: function() {
      if (!this.schema.loadUrl)
        return;
      let i = this;
      w.post("/api/query", {
        query: i.schema.datalistQuery
      }).onSuccess((e) => {
        i.schema.datalist = e.data.dropDown;
      }).withStorageMode(z.StorageAndUpdate).send();
    },
    saveData: function() {
    },
    deleteData: function() {
    }
  },
  created: function() {
    if (!this.schema.datalistQuery)
      return;
    this.fetchData();
  },
  watch: {
    model: function(i, e) {
      e !== i && (this.internalModel = i);
    }
  }
}), W = (i, e) => {
  const t = i.__vccOpts || i;
  for (const [r, s] of e)
    t[r] = s;
  return t;
};
function Ce(i, e, t, r, s, n) {
  return S(), D("div", null, [
    Z(" ASDF "),
    (S(!0), D(
      N,
      null,
      R(i.schema.children, (a) => (S(), ee(te(a.type), {
        key: a.type,
        data: i.internalData,
        schema: a,
        onSave: i.saveData,
        onDelete: i.deleteData,
        onLoad: i.fetchData
      }, null, 40, ["data", "schema", "onSave", "onDelete", "onLoad"]))),
      128
      /* KEYED_FRAGMENT */
    )),
    b(
      "pre",
      null,
      H(i.internalData),
      1
      /* TEXT */
    )
  ]);
}
const ke = /* @__PURE__ */ W(Ee, [["render", Ce]]), Ae = I.defineComponent({
  data: function() {
    return {
      items: this.items,
      showDropDown: !1
    };
  },
  props: {
    items: Array
  },
  methods: {
    showDropDownFunc: function() {
      this.showDropDown = !0;
    },
    hideDropDownFunc: function() {
      this.showDropDown = !1;
    }
  },
  directives: {
    clickOutside: f
  }
}), Te = { class: "unstyled" }, je = { class: "grouped" }, Fe = ["href"];
function Le(i, e, t, r, s, n) {
  const a = re("click-outside");
  return se((S(), D("ul", Te, [
    b("li", null, [
      b("a", {
        class: "fas fa-circle-user",
        href: "#",
        onClick: e[0] || (e[0] = ie((...o) => i.showDropDownFunc && i.showDropDownFunc(...o), ["stop", "prevent"]))
      }),
      b(
        "div",
        {
          class: q({ show: i.showDropDown, "z-depth-2": i.showDropDown, hidden: !i.showDropDown })
        },
        [
          b("ul", je, [
            (S(!0), D(
              N,
              null,
              R(i.items, (o) => (S(), D("li", {
                key: o.display
              }, [
                b("a", {
                  href: o.url,
                  class: q([o.icon])
                }, H(o.display), 11, Fe)
              ]))),
              128
              /* KEYED_FRAGMENT */
            ))
          ])
        ],
        2
        /* CLASS */
      )
    ])
  ])), [
    [a, i.hideDropDownFunc]
  ]);
}
const Oe = /* @__PURE__ */ W(Ae, [["render", Le]]), xe = (i) => {
  i.component("mithril-data-handler", ke), i.component("mithril-side-menu", Oe);
}, Ve = {
  install: (i, e) => {
    Pe(i), De(i), xe(i);
  }
};
class qe {
  // constructor
  constructor() {
    this.framework = new ve(), this.setupLogging();
  }
  // Sets up Vue components
  SetupComponents(e) {
    return e.use(Ve), e;
  }
  // Set up error logging.
  setupLogging() {
    h.configure().minimumLevel("Error").writeTo(new Me());
  }
}
class Me {
  // Writes a log event to the sink. This is called by the logger.
  // event: The event to write.
  write(e) {
    var s;
    if (!(e == null || !window.navigator.onLine)) {
      var t = ((s = e.exception) == null ? void 0 : s.stack) || "", r = e.message;
      t !== null && (r += `
 at ` + t), w.post("API/Command/v1/Log", { logLevel: "Error", message: r }).send();
    }
  }
}
class Re {
  constructor() {
    V(this, "Core");
    this.Core = new qe();
  }
}
export {
  C as BrowserUtils,
  ue as DatabaseConnection,
  Ne as Downloader,
  qe as Mithril,
  w as Request,
  z as StorageMode,
  Re as ThemeStartup
};

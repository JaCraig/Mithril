class h {
  // Creates a new default log output formatter
  // outputFormat: The output format to use when formatting log events (defaults to "{Timestamp}: [{Level}]: {Message}{Exception}")
  // The following placeholders can be used in the output format:
  // {Timestamp}: The timestamp of the log event
  // {Level}: The log level of the log event
  // {Message}: The message of the log event
  // {Exception}: The exception of the log event
  // {PropertyName}: The properties of the log event (where PropertyName is the name of the property)
  constructor(e) {
    this.outputFormat = e ?? "[{Timestamp}]	[{Level}]	{Message}{Exception}";
  }
  // Formats a log event into a string using the output format
  // event: The log event to format into a string
  // Returns the formatted log event
  format(e) {
    return this.outputFormat.replace(/{(\w+)}/g, (t, i) => i === "Timestamp" ? e.timestamp.toISOString() : i === "Level" ? e.level : i === "Message" ? e.message : i === "Exception" ? e.exception ? `
` + e.exception.stack : "" : e.properties[i]);
  }
}
class g {
  // Creates a new minimum level log filter
  // minimumLevel: The minimum level to write (defaults to "Debug")
  constructor(e = "Debug") {
    this.allowedLevels = ["Verbose", "Debug", "Information", "Warning", "Error", "Fatal"], this.minimumLevel = e, this.allowedLevels = this.allowedLevels.slice(this.allowedLevels.indexOf(e));
  }
  // Filters a log event and returns true if the event should be written to a sink or false if it should be discarded
  // event: The log event to filter
  // Returns true if the event should be written to a sink or false if it should be discarded
  filter(e) {
    return this.allowedLevels.indexOf(e.level) >= 0;
  }
}
class u {
  constructor() {
    this.styles = {
      Verbose: "color: white;",
      Debug: "color: green",
      Information: "color: blue",
      Warning: "color: yellow",
      Error: "color: red",
      Fatal: "color: palevioletred"
    }, this.consoleMethods = {
      Verbose: (e, t, i) => {
        console.log(e, t, i);
      },
      Debug: (e, t, i) => {
        console.debug(e, t, i);
      },
      Information: (e, t, i) => {
        console.info(e, t, i);
      },
      Warning: (e, t, i) => {
        console.warn(e, t, i);
      },
      Error: (e, t, i) => {
        console.error(e, t, i);
      },
      Fatal: (e, t, i) => {
        console.error(e, t, i);
      }
    };
  }
  // Writes a log event to the console
  // event: The log event to write
  write(e) {
    let t = e.args && typeof e.args != "object", i = e.args && typeof e.args == "object";
    this.consoleMethods[e.level]("%c" + e.message, this.styles[e.level], t ? e.args : ""), i && console.table(e.args);
  }
}
class n {
  // Creates a new log sink pipeline
  // loggerConfiguration: The logger configuration that the pipeline belongs to
  constructor(e) {
    this.filters = [], this.enrichers = [], this.loggerConfiguration = e;
  }
  // Sets the sink that the pipeline writes to
  // sink: The sink to write to
  // Returns the logger configuration that the pipeline belongs to
  writeTo(e) {
    return this.sink = e, this.loggerConfiguration;
  }
  // Adds a filter to the pipeline that filters log events by minimum level (lowest level to write)
  // level: The minimum level to write
  // Returns the pipeline
  minimumLevel(e) {
    return this.filters.push(new g(e)), this;
  }
  // Adds a filter to the pipeline that filters log events before they are written to the sink
  // filter: The filter to add
  // Returns the pipeline
  filter(e) {
    return this.filters.push(e), this;
  }
  // Sets the formatter that the pipeline uses to format log events before they are written to the sink
  // formatter: The formatter to use
  // Returns the pipeline
  formatUsing(e) {
    return this.formatter = e, this;
  }
  // Adds an enricher to the pipeline that enriches log events before they are written to the sink
  // enricher: The enricher to add
  // Returns the pipeline
  enrichWith(e) {
    return this.enrichers.push(e), this;
  }
  // Processes a log event by filtering, enriching and formatting it before writing it to the sink
  // event: The log event to process
  process(e) {
    this.formatter ?? (this.formatter = new h()), this.sink ?? (this.sink = new u());
    let t = Object.assign({}, e);
    this.filters.some((i) => i.filter(t)) && (this.enrichers.forEach((i) => i.enrich(t)), t.message = this.formatter.format(t) || t.message, this.sink.write(t));
  }
}
class p {
  constructor() {
    this.pipelines = [];
  }
  // Sets the sink that the pipeline writes to
  // sink: The sink to write to
  // Returns the logger configuration that the pipeline belongs to
  writeTo(e) {
    let t = new n(this);
    return this.pipelines.push(t), t.writeTo(e);
  }
  // Adds a filter to the pipeline that filters log events by minimum level (lowest level to write)
  // level: The minimum level to write
  // Returns the pipeline
  minimumLevel(e) {
    let t = new n(this);
    return this.pipelines.push(t), t.minimumLevel(e);
  }
  // Adds a filter to the pipeline that filters log events before they are written to the sink
  // filter: The filter to add
  // Returns the pipeline
  filter(e) {
    let t = new n(this);
    return this.pipelines.push(t), t.filter(e);
  }
  // Sets the formatter that the pipeline uses to format log events before they are written to the sink
  // formatter: The formatter to use
  // Returns the pipeline
  formatUsing(e) {
    let t = new n(this);
    return this.pipelines.push(t), t.formatUsing(e);
  }
  // Adds an enricher to the pipeline that enriches log events before they are written to the sink
  // enricher: The enricher to add
  // Returns the pipeline
  enrichWith(e) {
    let t = new n(this);
    return this.pipelines.push(t), t.enrichWith(e);
  }
  // Writes a log event to the configured sinks after processing it with the configured pipelines
  // level: The level of the log event
  // message: The message of the log event
  // properties: The properties of the log event
  // exception: The exception of the log event
  write(e, t, i, r) {
    let a = {
      level: e,
      message: t,
      properties: {},
      exception: r,
      timestamp: /* @__PURE__ */ new Date(),
      args: i
    };
    this.pipelines.forEach((c) => c.process(a));
  }
}
class l {
  // Hides the constructor
  constructor() {
  }
  // Gets the logger configuration that the logger uses to configure its sinks, filters, formatters and enrichers
  static configure() {
    return this.loggerConfiguration ?? (this.loggerConfiguration = window.LoggerConfiguration || new p()), window.LoggerConfiguration = this.loggerConfiguration, this.loggerConfiguration;
  }
  // Writes a log event to the logger
  // level: The level of the log event
  // message: The message of the log event
  // properties: The properties of the log event
  // exception: The exception of the log event
  static write(e, t, i, r) {
    l.configure().write(e, t, i, r);
  }
  // Writes a log event to the logger with the Verbose level
  // message: The message of the log event
  // properties: The properties of the log event
  static verbose(e, t) {
    this.write("Verbose", e, t);
  }
  // Writes a log event to the logger with the Debug level
  // message: The message of the log event
  // properties: The properties of the log event
  static debug(e, t) {
    this.write("Debug", e, t);
  }
  // Writes a log event to the logger with the Information level
  // message: The message of the log event
  // properties: The properties of the log event
  static information(e, t) {
    this.write("Information", e, t);
  }
  // Writes a log event to the logger with the Warning level
  // message: The message of the log event
  // properties: The properties of the log event
  static warning(e, t) {
    this.write("Warning", e, t);
  }
  // Writes a log event to the logger with the Error level
  // message: The message of the log event
  // properties: The properties of the log event
  // exception: The exception of the log event
  static error(e, t, i) {
    this.write("Error", e, t, i);
  }
  // Writes a log event to the logger with the Fatal level
  // message: The message of the log event
  // properties: The properties of the log event
  // exception: The exception of the log event
  static fatal(e, t, i) {
    this.write("Fatal", e, t, i);
  }
}
class s {
  // Returns the current domain.
  static get domain() {
    return window.location.protocol + "//" + window.location.host + "/";
  }
  // Determines if this is being run locally or in production.
  static get isLocal() {
    return /^http:\/\/localhost:\d{5}\/$/.test(s.domain);
  }
  // Gets the hash without the hash bang.
  static get HashBang() {
    return window.location.hash.replace("#!", "");
  }
  // Gets the text after the last slash. Presumably the ID needed.
  static get Id() {
    return window.location.pathname.substring(window.location.pathname.lastIndexOf("/") + 1);
  }
  // Gets a value from the query string.
  static GetQueryString(e) {
    let t = window.location.href;
    var i = new RegExp("[?&]" + e + "=([^&#]*)", "i"), r = i.exec(t);
    return r ? r[1] : null;
  }
  // Sets the title for the page.
  static setPageTitle(e) {
    document.title = e;
  }
}
class f {
  // constructor
  constructor() {
    l.debug("File Browser loading");
    var e = document.getElementsByTagName("a"), t = s.GetQueryString("host");
    t == null && (t = "/"), s.isLocal || (t = s.domain + t);
    for (var i = 0; i < e.length; ++i)
      e[i].addEventListener("click", function(r) {
        r.preventDefault();
        var a = this.href.replace(s.domain, "");
        return window.parent.postMessage(JSON.stringify({ href: a }), t), !1;
      });
    l.debug("File Browser loaded");
  }
  // FileBrowser application
  //private FileBrowserApp: Vue.App<Element>;
  // Sets up Vue components
  SetupComponents(e) {
  }
}
const w = (() => {
  new f();
})();
export {
  w as default
};

var Se = Object.defineProperty;
var $e = (e, t, a) => t in e ? Se(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a;
var ee = (e, t, a) => ($e(e, typeof t != "symbol" ? t + "" : t, a), a);
import y, { openBlock as r, createElementBlock as s, createTextVNode as p, toDisplayString as h, createCommentVNode as d, withDirectives as j, createElementVNode as l, vModelDynamic as ve, Fragment as b, renderList as S, normalizeClass as v, vModelSelect as ne, vModelText as ie, createBlock as q, resolveDynamicComponent as I, withModifiers as C, renderSlot as ke, resolveComponent as O, createVNode as N, withCtx as we, pushScopeId as B, popScopeId as R, createStaticVNode as Me, resolveDirective as De } from "vue";
import Q from "moment";
class Ee {
  // Creates a new default log output formatter
  // outputFormat: The output format to use when formatting log events (defaults to "{Timestamp}: [{Level}]: {Message}{Exception}")
  // The following placeholders can be used in the output format:
  // {Timestamp}: The timestamp of the log event
  // {Level}: The log level of the log event
  // {Message}: The message of the log event
  // {Exception}: The exception of the log event
  // {PropertyName}: The properties of the log event (where PropertyName is the name of the property)
  constructor(t) {
    this.outputFormat = t ?? "[{Timestamp}]	[{Level}]	{Message}{Exception}";
  }
  // Formats a log event into a string using the output format
  // event: The log event to format into a string
  // Returns the formatted log event
  format(t) {
    return this.outputFormat.replace(/{(\w+)}/g, (a, n) => n === "Timestamp" ? t.timestamp.toISOString() : n === "Level" ? t.level : n === "Message" ? t.message : n === "Exception" ? t.exception ? `
` + t.exception.stack : "" : t.properties[n]);
  }
}
class Te {
  // Creates a new minimum level log filter
  // minimumLevel: The minimum level to write (defaults to "Debug")
  constructor(t = "Debug") {
    this.allowedLevels = ["Verbose", "Debug", "Information", "Warning", "Error", "Fatal"], this.minimumLevel = t, this.allowedLevels = this.allowedLevels.slice(this.allowedLevels.indexOf(t));
  }
  // Filters a log event and returns true if the event should be written to a sink or false if it should be discarded
  // event: The log event to filter
  // Returns true if the event should be written to a sink or false if it should be discarded
  filter(t) {
    return this.allowedLevels.indexOf(t.level) >= 0;
  }
}
class Ce {
  constructor() {
    this.styles = {
      Verbose: "color: white;",
      Debug: "color: green",
      Information: "color: blue",
      Warning: "color: yellow",
      Error: "color: red",
      Fatal: "color: palevioletred"
    }, this.consoleMethods = {
      Verbose: (t, a, n) => {
        console.log(t, a, n);
      },
      Debug: (t, a, n) => {
        console.debug(t, a, n);
      },
      Information: (t, a, n) => {
        console.info(t, a, n);
      },
      Warning: (t, a, n) => {
        console.warn(t, a, n);
      },
      Error: (t, a, n) => {
        console.error(t, a, n);
      },
      Fatal: (t, a, n) => {
        console.error(t, a, n);
      }
    };
  }
  // Writes a log event to the console
  // event: The log event to write
  write(t) {
    let a = t.args && typeof t.args != "object", n = t.args && typeof t.args == "object";
    this.consoleMethods[t.level]("%c" + t.message, this.styles[t.level], a ? t.args : ""), n && console.table(t.args);
  }
}
class A {
  // Creates a new log sink pipeline
  // loggerConfiguration: The logger configuration that the pipeline belongs to
  constructor(t) {
    this.filters = [], this.enrichers = [], this.loggerConfiguration = t;
  }
  // Sets the sink that the pipeline writes to
  // sink: The sink to write to
  // Returns the logger configuration that the pipeline belongs to
  writeTo(t) {
    return this.sink = t, this.loggerConfiguration;
  }
  // Adds a filter to the pipeline that filters log events by minimum level (lowest level to write)
  // level: The minimum level to write
  // Returns the pipeline
  minimumLevel(t) {
    return this.filters.push(new Te(t)), this;
  }
  // Adds a filter to the pipeline that filters log events before they are written to the sink
  // filter: The filter to add
  // Returns the pipeline
  filter(t) {
    return this.filters.push(t), this;
  }
  // Sets the formatter that the pipeline uses to format log events before they are written to the sink
  // formatter: The formatter to use
  // Returns the pipeline
  formatUsing(t) {
    return this.formatter = t, this;
  }
  // Adds an enricher to the pipeline that enriches log events before they are written to the sink
  // enricher: The enricher to add
  // Returns the pipeline
  enrichWith(t) {
    return this.enrichers.push(t), this;
  }
  // Processes a log event by filtering, enriching and formatting it before writing it to the sink
  // event: The log event to process
  process(t) {
    this.formatter ?? (this.formatter = new Ee()), this.sink ?? (this.sink = new Ce());
    let a = Object.assign({}, t);
    this.filters.some((n) => n.filter(a)) && (this.enrichers.forEach((n) => n.enrich(a)), a.message = this.formatter.format(a) || a.message, this.sink.write(a));
  }
}
class Fe {
  constructor() {
    this.pipelines = [];
  }
  // Sets the sink that the pipeline writes to
  // sink: The sink to write to
  // Returns the logger configuration that the pipeline belongs to
  writeTo(t) {
    let a = new A(this);
    return this.pipelines.push(a), a.writeTo(t);
  }
  // Adds a filter to the pipeline that filters log events by minimum level (lowest level to write)
  // level: The minimum level to write
  // Returns the pipeline
  minimumLevel(t) {
    let a = new A(this);
    return this.pipelines.push(a), a.minimumLevel(t);
  }
  // Adds a filter to the pipeline that filters log events before they are written to the sink
  // filter: The filter to add
  // Returns the pipeline
  filter(t) {
    let a = new A(this);
    return this.pipelines.push(a), a.filter(t);
  }
  // Sets the formatter that the pipeline uses to format log events before they are written to the sink
  // formatter: The formatter to use
  // Returns the pipeline
  formatUsing(t) {
    let a = new A(this);
    return this.pipelines.push(a), a.formatUsing(t);
  }
  // Adds an enricher to the pipeline that enriches log events before they are written to the sink
  // enricher: The enricher to add
  // Returns the pipeline
  enrichWith(t) {
    let a = new A(this);
    return this.pipelines.push(a), a.enrichWith(t);
  }
  // Writes a log event to the configured sinks after processing it with the configured pipelines
  // level: The level of the log event
  // message: The message of the log event
  // properties: The properties of the log event
  // exception: The exception of the log event
  write(t, a, n, o) {
    let c = {
      level: t,
      message: a,
      properties: {},
      exception: o,
      timestamp: /* @__PURE__ */ new Date(),
      args: n
    };
    this.pipelines.forEach((i) => i.process(c));
  }
}
class f {
  // Hides the constructor
  constructor() {
  }
  // Gets the logger configuration that the logger uses to configure its sinks, filters, formatters and enrichers
  static configure() {
    return this.loggerConfiguration ?? (this.loggerConfiguration = window.LoggerConfiguration || new Fe()), window.LoggerConfiguration = this.loggerConfiguration, this.loggerConfiguration;
  }
  // Writes a log event to the logger
  // level: The level of the log event
  // message: The message of the log event
  // properties: The properties of the log event
  // exception: The exception of the log event
  static write(t, a, n, o) {
    f.configure().write(t, a, n, o);
  }
  // Writes a log event to the logger with the Verbose level
  // message: The message of the log event
  // properties: The properties of the log event
  static verbose(t, a) {
    this.write("Verbose", t, a);
  }
  // Writes a log event to the logger with the Debug level
  // message: The message of the log event
  // properties: The properties of the log event
  static debug(t, a) {
    this.write("Debug", t, a);
  }
  // Writes a log event to the logger with the Information level
  // message: The message of the log event
  // properties: The properties of the log event
  static information(t, a) {
    this.write("Information", t, a);
  }
  // Writes a log event to the logger with the Warning level
  // message: The message of the log event
  // properties: The properties of the log event
  static warning(t, a) {
    this.write("Warning", t, a);
  }
  // Writes a log event to the logger with the Error level
  // message: The message of the log event
  // properties: The properties of the log event
  // exception: The exception of the log event
  static error(t, a, n) {
    this.write("Error", t, a, n);
  }
  // Writes a log event to the logger with the Fatal level
  // message: The message of the log event
  // properties: The properties of the log event
  // exception: The exception of the log event
  static fatal(t, a, n) {
    this.write("Fatal", t, a, n);
  }
}
class qe {
  // Constructor
  // dbName: The name of the database
  // tables: The tables to create
  // version: The version of the database
  constructor(t, a, n) {
    this.dbName = t, this.tables = a, this.version = n;
    const o = indexedDB.open(t, n);
    o.onupgradeneeded = (c) => {
      this.database = c.target.result;
      for (const i of a)
        this.database.objectStoreNames.contains(i) && this.database.deleteObjectStore(i), this.database.createObjectStore(i);
    }, o.onsuccess = (c) => {
      this.database = c.target.result;
    }, o.onerror = (c) => {
      f.error("Failed to open the database:", c.target.error);
    };
  }
  // Opens the database connection
  openDatabase() {
    return new Promise((t, a) => {
      const n = indexedDB.open(this.dbName, this.version);
      n.onsuccess = (o) => {
        this.database = o.target.result, t(this);
      }, n.onerror = (o) => {
        f.error("Failed to open the database:", o.target.error), a(new Error("Failed to open the database:" + o.target.error));
      };
    });
  }
  // Adds an object to the database
  // table: The table to add the object to
  // obj: The object to add
  // key: The key to add the object with
  add(t, a, n) {
    return new Promise((o, c) => {
      const m = this.database.transaction(t, "readwrite").objectStore(t).put(a, n);
      m.onsuccess = () => {
        o();
      }, m.onerror = (g) => {
        f.error("Failed to add an object to the database: ", g.target.error), c(new Error("Failed to add an object to the database: " + g.target.error));
      };
    });
  }
  // Removes an object from the database
  // table: The table to remove the object from
  // key: The key of the object to remove
  remove(t, a) {
    return new Promise((n, o) => {
      const u = this.database.transaction(t, "readwrite").objectStore(t).delete(a);
      u.onsuccess = () => {
        n();
      }, u.onerror = (m) => {
        f.error("Failed to remove an object from the database: ", m.target.error), o(new Error("Failed to remove an object from the database: " + m.target.error));
      };
    });
  }
  // Gets an object from the database by key
  // table: The table to get the object from
  // key: The key of the object to get
  getByKey(t, a) {
    return new Promise((n, o) => {
      const u = this.database.transaction(t, "readwrite").objectStore(t).get(a);
      u.onsuccess = (m) => {
        n(m.target.result);
      }, u.onerror = (m) => {
        f.error("Failed to retrieve an object from the database: ", m.target.error), o(new Error("Failed to retrieve an object from the database: " + m.target.error));
      };
    });
  }
  // Gets all objects from the database
  // table: The table to get the objects from
  // query: The query to filter the objects by
  getKeys(t) {
    return new Promise((a, n) => {
      const i = this.database.transaction(t, "readwrite").objectStore(t).getAllKeys();
      i.onsuccess = (u) => {
        a(u.target.result);
      }, i.onerror = (u) => {
        f.error("Failed to retrieve an object from the database: ", u.target.error), n(new Error("Failed to retrieve keys from the database: " + u.target.error));
      };
    });
  }
  // Gets an object from the database by key
  // table: The table to get the object from
  // query: The query to filter the objects by
  get(t, a) {
    return new Promise((n, o) => {
      const u = this.database.transaction(t, "readwrite").objectStore(t).get(a);
      u.onsuccess = (m) => {
        n(m.target.result);
      }, u.onerror = (m) => {
        f.error("Failed to retrieve an object from the database: ", m.target.error), o(new Error("Failed to retrieve an object from the database: " + m.target.error));
      };
    });
  }
  // Gets all objects from the database
  // table: The table to get the objects from
  // query: The query to filter the objects by
  getAll(t, a) {
    return new Promise((n, o) => {
      const u = this.database.transaction(t, "readwrite").objectStore(t).getAll(a);
      u.onsuccess = (m) => {
        n(m.target.result);
      }, u.onerror = (m) => {
        f.error("Failed to retrieve an object from the database: ", m.target.error), o(new Error("Failed to retrieve objects from the database: " + m.target.error));
      };
    });
  }
}
class te {
  // Constructor
  constructor() {
    this.database = new qe("cacheStore", ["cache", "cacheEntryOptions"], 1);
  }
  // Clears the database of all items and options
  // Returns a promise that resolves when the operation is complete
  async clear() {
    await this.database.openDatabase();
    let t = await this.database.getAll("cacheEntryOptions"), a = await this.database.getAll("cache");
    for (let n = 0; n < t.length; n++) {
      let o = a[n];
      await this.remove(o.key);
    }
    return this;
  }
  // Gets the options for an object in the database by key
  // key: The key of the object to get the options for
  // Returns a promise that resolves with the options
  async getOptions(t) {
    return await this.database.openDatabase(), this.database.getByKey("cacheEntryOptions", t);
  }
  // Adds an object to the database
  // obj: The object to add
  // key: The key to add the object with
  // options: The options to add the object with
  async add(t, a, n) {
    return await this.database.openDatabase(), await this.database.add("cache", t, a), await this.database.add("cacheEntryOptions", n, a), this;
  }
  // Removes an object from the database
  // key: The key of the object to remove
  async remove(t) {
    return await this.database.openDatabase(), await this.database.remove("cache", t), await this.database.remove("cacheEntryOptions", t), this;
  }
  // Gets an object from the database by key
  // table: The table to get the object from
  // key: The key of the object to get
  async get(t) {
    return await this.database.openDatabase(), this.database.getByKey("cache", t);
  }
  // Compacts the database. This is used to remove expired items from the database.
  // This method is called automatically by the cache.
  // Returns a promise that resolves when the operation is complete
  async compact() {
    await this.database.openDatabase();
    let t = await this.database.getAll("cacheEntryOptions"), a = await this.database.getAll("cache"), n = (/* @__PURE__ */ new Date()).getTime();
    for (let o = 0; o < t.length; o++) {
      let c = t[o], i = a[o];
      c.expirationTime != 0 && c.expirationTime < n && await this.remove(i.key);
    }
    return this;
  }
}
class H {
  // Hides the constructor
  constructor() {
  }
  // Configures the cache with the specified storage provider
  // storageProvider: The storage provider to use for the cache
  static configure(t = new te()) {
    this.storageProvider ?? (this.storageProvider = window.StorageProvider || new te()), window.StorageProvider = this.storageProvider;
  }
  // Sets an object in the cache by key with the specified options
  // key: The key to set the object with
  // value: The value to set the object with
  // entryOptions: The options to set the object with
  // Returns a promise that resolves when the operation is complete
  static async set(t, a, n = { expirationTime: 0, slidingExpirationTime: 0, sliding: !1 }) {
    f.debug("Setting object in cache: ", { key: t, value: a, entryOptions: n }), this.configure(), await this.storageProvider.add(a, t, n);
  }
  // Gets an object from the cache by key and resets the expiration time if the object is set to sliding expiration
  // key: The key of the object to get
  // Returns a promise that resolves with the object
  static async get(t) {
    f.debug("Getting object from cache: " + t), this.configure(), await this.storageProvider.compact();
    let a = await this.storageProvider.get(t);
    if (a == null)
      return a;
    let n = await this.storageProvider.getOptions(t);
    return n.sliding && await this.set(t, a, {
      expirationTime: (/* @__PURE__ */ new Date()).getTime() + n.slidingExpirationTime,
      slidingExpirationTime: n.slidingExpirationTime,
      sliding: !0
    }), a;
  }
  // Removes an object from the cache by key
  // key: The key of the object to remove
  // Returns a promise that resolves when the operation is complete
  static async remove(t) {
    f.debug("Removing object from cache: " + t), this.configure(), await this.storageProvider.remove(t);
  }
  // Clears the cache of all items
  // Returns a promise that resolves when the operation is complete
  static async clear() {
    f.debug("Clearing cache"), this.configure(), await this.storageProvider.clear();
  }
}
class Ie {
}
class k {
  // Constructor
  // options: The request options
  constructor(t) {
    this.options = {
      method: "GET",
      url: "",
      headers: {},
      credentials: "same-origin",
      serializer: JSON.stringify,
      parser: (a) => a.json(),
      success: (a) => {
        f.debug("Request response from " + this.options.url + ":", a);
      },
      error: (a) => {
        f.error("Request error from " + this.options.url + ":", a);
      },
      retry: (a) => {
        f.debug("Request retry on " + this.options.url + ":", { attempt: a });
      },
      storageMode: 0,
      cacheKey: "",
      timeout: 6e4,
      retryAttempts: 3,
      retryDelay: 1e3
    }, this.abortController = null, this.options = { ...this.options, ...t };
  }
  // Creates a GET request
  // Note: GET requests are cached by default
  // url: The request url
  // data: The request data
  static get(t, a) {
    return new k({ method: "GET", url: t, data: a, cacheKey: t + JSON.stringify(a) }).withHeaders({
      Accept: "application/json"
    });
  }
  // Creates a POST request
  // Note: POST requests are not cached by default
  // url: The request url
  // data: The request data
  static post(t, a) {
    return new k({
      method: "POST",
      url: t,
      data: a,
      cacheKey: t + JSON.stringify(a),
      storageMode: 2
      /* NetworkOnly */
    }).withHeaders({
      "Content-Type": "application/json",
      Accept: "application/json"
    });
  }
  // Creates a PUT request
  // Note: PUT requests are not cached by default
  // url: The request url
  // data: The request data
  static put(t, a) {
    return new k({
      method: "PUT",
      url: t,
      data: a,
      cacheKey: t + JSON.stringify(a),
      storageMode: 2
      /* NetworkOnly */
    }).withHeaders({
      "Content-Type": "application/json",
      Accept: "application/json"
    });
  }
  // Creates a DELETE request
  // Note: DELETE requests are not cached by default
  // url: The request url
  // data: The request data
  static delete(t, a) {
    return new k({
      method: "DELETE",
      url: t,
      data: a,
      cacheKey: t + JSON.stringify(a),
      storageMode: 2
      /* NetworkOnly */
    }).withHeaders({
      Accept: "application/json"
    });
  }
  // Creates a request of the specified type (e.g. GET, POST, PUT, DELETE, etc.)
  // method: The request method
  // url: The request url
  // data: The request data
  static ofType(t, a, n) {
    return new k({ method: t, url: a, data: n, cacheKey: a + JSON.stringify(n) }).withHeaders({
      Accept: "application/json"
    });
  }
  // Adds an authentication provider to the request (used to authenticate the request)
  // authenticationProvider: The authentication provider
  withAuthenticationProvider(t) {
    return this.options.authenticationProvider = t, this;
  }
  // Adds header values to the request
  // headers: The header values
  withHeaders(t) {
    return this.options.headers = { ...this.options.headers, ...t }, this;
  }
  // Adds a cancellation token to the request (used to cancel the request)
  // cancellationToken: The cancellation token
  // Note: The request will finish executing, but the success/error callbacks will not be called if the request is cancelled.
  withCancellationToken(t) {
    return this.options.cancellationToken = t, this;
  }
  // Adds credentials to the request
  // credentials: The credentials
  withCredentials(t) {
    return this.options.credentials = t, this;
  }
  // Sets the serializer for the request
  // serializer: The serializer
  withSerializer(t) {
    return this.options.serializer = t, this;
  }
  // Sets the parser for the request
  // parser: The parser
  withParser(t) {
    return this.options.parser = t, this;
  }
  // Sets the success callback for the request
  // callback: The success callback
  onSuccess(t) {
    return this.options.success = t ?? ((a) => {
      f.debug("Request response:", a);
    }), this;
  }
  // Sets the error callback for the request
  // callback: The error callback
  onError(t) {
    return this.options.error = t ?? ((a) => {
      f.error("Request error:", a);
    }), this;
  }
  // Sets the retry callback for the request
  // callback: The retry callback
  onRetry(t) {
    return this.options.retry = t ?? ((a) => {
      f.debug("Request retry:", { attempt: a });
    }), this;
  }
  // Sets the storage mode for the request
  // storageMode: The storage mode
  withStorageMode(t) {
    return this.options.storageMode = t, this;
  }
  // Sets the cache key for the request
  // cacheKey: The cache key
  withCacheKey(t) {
    return this.options.cacheKey = t, this;
  }
  // Sets the timeout for the request
  // timeout: The timeout in milliseconds (default: 60000)
  // Note: The timeout is only used for network requests
  withTimeout(t) {
    return this.options.timeout = t ?? 6e4, this;
  }
  // Sets the number of retry attempts for the request
  // retryAttempts: The number of retry attempts (default: 3)
  // Note: The retry attempts are only used for network requests
  withRetryAttempts(t) {
    return this.options.retryAttempts = t, this;
  }
  // Sets the retry delay for the request in milliseconds
  // retryDelay: The retry delay in milliseconds (default: 1000)
  // Note: The retry delay is only used for network requests
  withRetryDelay(t) {
    return this.options.retryDelay = t, this;
  }
  // Aborts the request, if it is still running, and calls the error callback.
  // Note: This is only supported for network requests
  abort() {
    return this.abortController === null ? this : (this.abortController.abort(), this.options.error(new Error("The request was aborted.")), this);
  }
  // Actually sends the request, parses it, and calls either the
  // success or error functions if they exist.
  // Returns the parsed response.
  async send() {
    const { authenticationProvider: t, method: a, url: n, data: o, headers: c, credentials: i, serializer: u, parser: m, success: g, error: w, storageMode: T, cacheKey: Y, timeout: pe, retryAttempts: ge, retryDelay: ye, retry: be, cancellationToken: _ } = this.options, X = new AbortController();
    this.abortController = X;
    let K = 0, P = null;
    const x = async () => {
      if (T === 1 || T === 3) {
        const M = await H.get(Y);
        if (M !== void 0 && (g(M), T === 1))
          return M;
      }
      if (!navigator.onLine) {
        if (T === 0) {
          const D = await H.get(Y);
          if (D !== void 0)
            return g(D), D;
        }
        const M = new Error("System is offline");
        return w(M), Promise.reject(M);
      }
      try {
        const M = u(o);
        await (t == null ? void 0 : t.authenticate(this));
        const D = await Promise.race([
          fetch(n, {
            method: a,
            credentials: i,
            headers: c,
            body: M,
            signal: X.signal
          }),
          this.handleTimeout(pe)
        ]);
        if (_ != null && _.canceled)
          return Promise.reject(new Error("The request was canceled."));
        if (D.status >= 200 && D.status < 300) {
          const G = await m(D);
          return g(G), T !== 2 && await H.set(Y, G), G;
        }
        P = new Error(D.statusText), D.status === 401 && await (t == null ? void 0 : t.authenticationFailed(this, D));
      } catch (M) {
        P = M;
      }
      return K < ge ? (++K, await new Promise((M) => setTimeout(M, ye)), be(K), x()) : (w(P), Promise.reject(P));
    };
    return x();
  }
  // Handles the timeout for the request
  // timeout: The timeout in milliseconds (default: 60000)
  // returns: A promise that rejects when the timeout is reached
  async handleTimeout(t) {
    throw t ?? (t = 6e4), await new Promise((a, n) => {
      setTimeout(() => {
        n(new Error("Request timeout"));
      }, t);
    }), new Error("Request timeout");
  }
}
var V = /* @__PURE__ */ ((e) => (e[e.NetworkFirst = 0] = "NetworkFirst", e[e.StorageFirst = 1] = "StorageFirst", e[e.NetworkOnly = 2] = "NetworkOnly", e[e.StorageAndUpdate = 3] = "StorageAndUpdate", e))(V || {});
String.prototype.slugify = function() {
  return this.trim().replace(/ /g, "-").replace(/-{2,}/g, "-").replace(/^-+|-+$/g, "").replace(/([^a-zA-Z0-9-_/./:]+)/g, "");
};
String.prototype.stripHTML = function() {
  let e = document.createElement("div");
  return e.innerHTML = this, (e.textContent || e.innerText || "").replace(/^\s+|\s+$/g, "");
};
String.prototype.toNumber = function() {
  return this == null ? 0 : parseFloat(this.stripHTML().replace(/[^0-9.-]/g, ""));
};
function z(e, t = 300) {
  let a;
  return function(...n) {
    clearTimeout(a), a = setTimeout(() => {
      e.apply(this, n);
    }, t);
  };
}
class F {
}
class L {
  constructor() {
    this.name = "inputElement";
  }
  // The validation method. This method should return a promise that resolves to true if the value is valid, or false if it is not.
  // value: The value to validate
  // params: Any additional parameters to pass to the validation method
  // Returns a promise that resolves to true if the value is valid, or false if it is not.
  validate(t, ...a) {
    let n = t;
    return n == null ? new Promise((o, c) => {
      o({ isValid: !0, errorMessage: "" });
    }) : new Promise((o, c) => {
      n.checkValidity() ? o({ isValid: !0, errorMessage: n.validationMessage }) : o({ isValid: !1, errorMessage: n.validationMessage });
    });
  }
}
class J {
  constructor() {
    this.name = "selectElement";
  }
  // The validation method. This method should return a promise that resolves to true if the value is valid, or false if it is not.
  // value: The value to validate
  // params: Any additional parameters to pass to the validation method
  // Returns a promise that resolves to true if the value is valid, or false if it is not.
  validate(t, ...a) {
    let n = t;
    return n == null ? new Promise((o, c) => {
      o({ isValid: !0, errorMessage: "" });
    }) : new Promise((o, c) => {
      n.checkValidity() ? o({ isValid: !0, errorMessage: n.validationMessage }) : o({ isValid: !1, errorMessage: n.validationMessage });
    });
  }
}
class je {
  constructor() {
    this.name = "textAreaElement";
  }
  // The validation method. This method should return a promise that resolves to true if the value is valid, or false if it is not.
  // value: The value to validate
  // params: Any additional parameters to pass to the validation method
  // Returns a promise that resolves to true if the value is valid, or false if it is not.
  validate(t, ...a) {
    let n = t;
    return n == null ? new Promise((o, c) => {
      o({ isValid: !0, errorMessage: "" });
    }) : new Promise((o, c) => {
      n.checkValidity() ? o({ isValid: !0, errorMessage: n.validationMessage }) : o({ isValid: !1, errorMessage: n.validationMessage });
    });
  }
}
class Ve {
  // Constructor - private to prevent instantiation
  constructor() {
  }
  // Initializes the validation rules
  static initialize() {
    this.rules ?? (this.rules = window.ValidationConfiguration || {}), window.ValidationConfiguration = this.rules;
  }
  // Adds a validation rule group to the list of validation rules
  // name: The name of the validation rule group
  // group: The validation rule group to add
  static addRuleGroup(t, a) {
    this.initialize(), this.rules[t] = a;
  }
  // Validates an object against a validation rule group
  // obj: The object to validate
  // ruleGroup: The name of the validation rule group to validate against
  // errors: An optional object to populate with errors if the object is invalid (the key is the property name, the value is an array of error messages) (optional)
  // Returns a promise that resolves to true if the object is valid, or false if it is not
  static async validate(t, a, n = {}) {
    this.initialize();
    let o = !0, c = this.rules[a];
    if (!c)
      return o;
    for (let i in c) {
      if (!c.hasOwnProperty(i))
        continue;
      let u = t[i], m = c[i];
      for (let g = 0; g < m.length; g++) {
        let T = await m[g].validate(u);
        T.isValid || (o = !1, n.hasOwnProperty(i) ? n[i].push(T.errorMessage) : n[i] = [T.errorMessage]);
      }
    }
    return o;
  }
  // Validates a form
  // form: The form to validate
  // errors: An optional object to populate with errors if the form is invalid (the key is the property name, the value is an array of error messages) (optional)
  // ruleGroup: The name of the validation rule group to validate against (optional)
  // Returns a promise that resolves to true if the form is valid, or false if it is not
  static async validateForm(t, a = null, n = {}) {
    this.initialize(), a ?? (a = t.getAttribute("data-validation-rule-group")), a || (a = this.deriveObjectType(t));
    let o = this.rules[a];
    o || (o = this.extractRulesFromForm(t), this.addRuleGroup(a, o));
    const c = this.extractFormData(t);
    return this.validate(c, a, n);
  }
  // Extracts the form data from a form and returns it as an array
  // form: The form to extract the data from
  // Returns an array of form data
  static extractFormData(t) {
    let a = {}, n = t.getElementsByTagName("input"), o = t.getElementsByTagName("textarea"), c = t.getElementsByTagName("select");
    for (let i = 0; i < n.length; i++)
      a[n[i].name] = n[i];
    for (let i = 0; i < o.length; i++)
      a[o[i].name] = o[i];
    for (let i = 0; i < c.length; i++)
      a[c[i].name] = c[i];
    return a;
  }
  // Derives the object type from a form element (if no object type is specified)
  // form: The form to derive the object type from
  // Returns the object type
  static deriveObjectType(t) {
    return t.action || t.id || t.name;
  }
  // Extracts the validation rules from a form and adds them to the list of validation rules
  // form: The form to extract the validation rules from
  // Returns the validation rule group that was extracted
  static extractRulesFromForm(t) {
    var i, u, m;
    let a = {}, n = t.getElementsByTagName("input"), o = t.getElementsByTagName("textarea"), c = t.getElementsByTagName("select");
    for (let g = 0; g < n.length; ++g) {
      let w = n[g];
      w.willValidate && (a[i = w.name] ?? (a[i] = []), a[w.name].push(new L()));
    }
    for (let g = 0; g < o.length; ++g) {
      let w = o[g];
      w.willValidate && (a[u = w.name] ?? (a[u] = []), a[w.name].push(new je()));
    }
    for (let g = 0; g < c.length; ++g) {
      let w = c[g];
      w.willValidate && (a[m = w.name] ?? (a[m] = []), a[w.name].push(new J()));
    }
    return a;
  }
}
const Ae = y.defineComponent({
  name: "form-field-input",
  data: function() {
    return {
      internalModel: this.formatValue(this.model),
      internalSchema: this.schema,
      dataListQuery: "query($queryType: String!, $queryFilter: String!) { dropDown(type: $queryType, filter: $queryFilter) { key, value } }",
      errorMessage: ""
    };
  },
  props: {
    model: {
      type: String,
      required: !0,
      default: ""
    },
    schema: {
      type: F,
      required: !0,
      default: () => new F()
    },
    showLabel: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  methods: {
    // determines if the field should be validated
    willValidate: function() {
      return this.internalSchema.metadata.required || this.internalSchema.metadata.maxlength || this.internalSchema.metadata.minlength || this.internalSchema.metadata.pattern || this.internalSchema.metadata.min || this.internalSchema.metadata.max;
    },
    // revalidates the field
    revalidate: async function() {
      let e = document.getElementById(this.getFieldID());
      if (e == null)
        return;
      let t = await new L().validate(e);
      return this.errorMessage = t.errorMessage, t.isValid;
    },
    // converts the value to a date
    // value: the value to convert
    convertToDate: function(e) {
      return this.schema.metadata.isUTC ? Q.utc(e || /* @__PURE__ */ new Date()).local() : Q(e || /* @__PURE__ */ new Date());
    },
    // formats the value to the correct format
    // value: the value to format
    formatValue: function(e) {
      return e && (this.schema.metadata.inputType === "date" ? this.convertToDate(e).format("YYYY-MM-DD") : this.schema.metadata.inputType === "datetime-local" || this.schema.metadata.inputType === "datetime" ? this.convertToDate(e).format("YYYY-MM-DDTHH:mm") : this.schema.metadata.inputType === "month" ? this.convertToDate(e).format("YYYY-MM") : e);
    },
    // gets the field id
    getFieldID: function() {
      return this.internalSchema.propertyName.slugify() + this.internalSchema.key;
    },
    // Called when the model changes
    // newValue: the new value
    // emits a changed event
    changed: function(e) {
      this.updateDataList(), this.revalidate(), this.$emit("changed", e, this.schema);
    },
    // Gets the datalist id
    getList: function() {
      return this.schema.metadata.datalist ? this.getFieldID() + "-list" : null;
    },
    // Updates the datalist for the field
    updateDataList: z(async function() {
      if (!this.internalSchema.queryType)
        return;
      let e = this;
      k.post("/api/query", {
        query: e.datalistQuery,
        variables: {
          queryType: e.internalSchema.metadata.queryType,
          queryFilter: e.internalModel
        }
      }).onSuccess((t) => {
        f.debug("Select: " + e.internalSchema.metadata.queryType + " loaded successfully.", t.data.dropDown), e.internalSchema.metadata.datalist = t.data.dropDown;
      }).onError((t) => {
        f.error("Select: " + e.internalSchema.metadata.queryType + " failed to load.", t);
      }).withStorageMode(V.StorageAndUpdate).send();
    }, 300)
  },
  // created method, updates the datalist values
  created: function() {
    this.updateDataList();
  },
  watch: {
    // watches the model and updates the internal model
    // newModel: the new model
    // oldModel: the old model
    model: function(e, t) {
      t !== e && (this.internalModel = e, this.$nextTick(function() {
        this.revalidate();
      }));
    },
    // watches the schema and updates the internal schema
    // newSchema: the new schema
    // oldSchema: the old schema
    schema: function(e, t) {
      t !== e && (this.internalSchema = e, this.$nextTick(function() {
        this.revalidate();
      }));
    }
  },
  // mounted method, revalidates the field
  mounted: function() {
    this.$nextTick(function() {
      this.revalidate();
    });
  }
}), $ = (e, t) => {
  const a = e.__vccOpts || e;
  for (const [n, o] of t)
    a[n] = o;
  return a;
}, Oe = ["for"], Ne = {
  key: 0,
  class: "error clear-background"
}, Le = {
  key: 1,
  class: "clear-background active no-border small"
}, Pe = /* @__PURE__ */ l("span", { class: "fas fa-info-circle" }, null, -1), Be = {
  key: 2,
  class: "error clear-background"
}, Re = {
  key: 3,
  class: "success clear-background fas fa-check-circle"
}, ze = { key: 1 }, Ue = ["id", "type", "disabled", "accept", "alt", "autocomplete", "checked", "dirname", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "title", "readonly", "required", "size", "src", "step", "width", "files", "data-error-message-value-missing", "data-error-message-pattern-mismatch", "data-error-message-range-overflow", "data-error-message-range-underflow", "data-error-message-step-mismatch", "data-error-message-too-long", "data-error-message-too-short", "data-error-message-bad-input", "data-error-message-type-mismatch"], Ye = {
  key: 2,
  class: "text-center"
}, _e = ["id"], Ke = ["value"];
function Ge(e, t, a, n, o, c) {
  return r(), s("div", null, [
    e.showLabel && e.internalSchema.displayName ? (r(), s("label", {
      key: 0,
      for: e.getFieldID()
    }, [
      p(h(e.internalSchema.displayName) + " ", 1),
      e.internalSchema.metadata.required && e.errorMessage ? (r(), s("span", Ne, "*")) : d("", !0),
      e.internalSchema.metadata.hint ? (r(), s("i", Le, [
        Pe,
        p(h(e.internalSchema.metadata.hint), 1)
      ])) : d("", !0),
      e.errorMessage ? (r(), s("span", Be, h(e.errorMessage), 1)) : d("", !0),
      !e.errorMessage && e.willValidate() ? (r(), s("span", Re)) : d("", !0)
    ], 8, Oe)) : d("", !0),
    e.internalSchema.metadata.subtitle ? (r(), s("div", ze, h(e.internalSchema.metadata.subtitle), 1)) : d("", !0),
    j(l("input", {
      id: e.getFieldID(),
      type: e.internalSchema.metadata.inputType,
      "onUpdate:modelValue": t[0] || (t[0] = (i) => e.internalModel = i),
      onInput: t[1] || (t[1] = (i) => e.changed(i.target.value)),
      disabled: e.internalSchema.metadata.disabled,
      accept: e.internalSchema.metadata.accept,
      alt: e.internalSchema.metadata.alt,
      autocomplete: e.internalSchema.metadata.autocomplete,
      checked: e.internalSchema.metadata.checked,
      dirname: e.internalSchema.metadata.dirname,
      formaction: e.internalSchema.metadata.formaction,
      formenctype: e.internalSchema.metadata.formenctype,
      formmethod: e.internalSchema.metadata.formmethod,
      formnovalidate: e.internalSchema.metadata.formnovalidate,
      formtarget: e.internalSchema.metadata.formtarget,
      height: e.internalSchema.metadata.height,
      list: e.getList(),
      max: e.internalSchema.metadata.max,
      maxlength: e.internalSchema.metadata.maxlength,
      min: e.internalSchema.metadata.min,
      minlength: e.internalSchema.metadata.minlength,
      multiple: e.internalSchema.metadata.multiple,
      name: e.getFieldID(),
      pattern: e.internalSchema.metadata.pattern,
      placeholder: e.internalSchema.metadata.placeholder,
      title: e.internalSchema.metadata.placeholder,
      readonly: e.internalSchema.metadata.readonly,
      required: e.internalSchema.metadata.required,
      size: e.internalSchema.metadata.size,
      src: e.internalSchema.metadata.src,
      step: e.internalSchema.metadata.step,
      width: e.internalSchema.metadata.width,
      files: e.internalSchema.metadata.files,
      "data-error-message-value-missing": e.internalSchema.metadata.errorMessageValueMissing,
      "data-error-message-pattern-mismatch": e.internalSchema.metadata.errorMessagePatternMismatch,
      "data-error-message-range-overflow": e.internalSchema.metadata.errorMessageRangeOverflow,
      "data-error-message-range-underflow": e.internalSchema.metadata.errorMessageRangeUnderflow,
      "data-error-message-step-mismatch": e.internalSchema.metadata.errorMessageStepMismatch,
      "data-error-message-too-long": e.internalSchema.metadata.errorMessageTooLong,
      "data-error-message-too-short": e.internalSchema.metadata.errorMessageTooShort,
      "data-error-message-bad-input": e.internalSchema.metadata.errorMessageBadInput,
      "data-error-message-type-mismatch": e.internalSchema.metadata.errorMessageTypeMismatch
    }, null, 40, Ue), [
      [ve, e.internalModel]
    ]),
    e.internalSchema.metadata.inputType === "color" || e.internalSchema.metadata.inputType === "range" ? (r(), s("div", Ye, h(e.internalModel), 1)) : d("", !0),
    e.internalSchema.metadata.datalist ? (r(), s("datalist", {
      key: 3,
      id: e.getList()
    }, [
      (r(!0), s(b, null, S(e.internalSchema.metadata.datalist, (i) => (r(), s("option", {
        value: i.value,
        key: i.key
      }, null, 8, Ke))), 128))
    ], 8, _e)) : d("", !0)
  ]);
}
const re = /* @__PURE__ */ $(Ae, [["render", Ge]]), He = y.defineComponent({
  name: "form-field-select",
  data: function() {
    return {
      internalModel: this.model,
      internalSchema: this.schema,
      optionsQuery: "query($queryType: String!) { dropDown(type: $queryType) { key, value } }",
      errorMessage: ""
    };
  },
  props: {
    model: {
      type: String,
      required: !0,
      default: ""
    },
    schema: {
      type: F,
      required: !0,
      default: () => new F()
    },
    showLabel: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  methods: {
    // determines if the field will be validated
    willValidate: function() {
      return this.internalSchema.metadata.required;
    },
    // revalidate the input field
    revalidate: async function() {
      let e = await new J().validate(document.getElementById(this.getFieldID()));
      return this.errorMessage = e.errorMessage, e.isValid;
    },
    // gets the field id
    getFieldID: function() {
      return this.internalSchema.propertyName.slugify() + this.internalSchema.key;
    },
    // called when the value changes
    // emits the changed event
    // newValue: the new value
    changed: function(e) {
      this.revalidate(), this.$emit("changed", e, this.schema);
    },
    // determines if the value is selected
    // value: the value to check
    isSelected: function(e) {
      return this.internalModel === e.key;
    },
    // gets the values for the select element
    getValues: async function() {
      if (!this.internalSchema.metadata.queryType)
        return;
      let e = this;
      f.debug("Select: Getting values for " + this.internalSchema.metadata.queryType), await k.post("/api/query", {
        query: e.optionsQuery,
        variables: {
          queryType: e.internalSchema.metadata.queryType
        }
      }).onSuccess((t) => {
        f.debug("Select: " + e.internalSchema.metadata.queryType + " loaded successfully.", t.data.dropDown), e.internalSchema.metadata.options = t.data.dropDown;
      }).onError((t) => {
        f.error("Select: " + e.internalSchema.metadata.queryType + " failed to load.", t);
      }).withStorageMode(V.StorageAndUpdate).send();
    }
  },
  // created event, gets the values for the select element
  created: function() {
    this.getValues();
  },
  watch: {
    // watches the model and revalidates when it changes
    // newModel: the new model
    // oldModel: the old model
    model: function(e, t) {
      t !== e && (this.internalModel = e, this.$nextTick(function() {
        this.revalidate();
      }));
    },
    // watches the schema and revalidates when it changes
    // newSchema: the new schema
    // oldSchema: the old schema
    schema: function(e, t) {
      t !== e && (this.internalSchema = e, this.$nextTick(function() {
        this.revalidate();
      }));
    }
  },
  // mounted event, revalidates the field
  mounted: function() {
    this.$nextTick(function() {
      this.revalidate();
    });
  }
}), Qe = ["for"], Je = {
  key: 0,
  class: "error clear-background"
}, We = {
  key: 1,
  class: "clear-background active no-border small"
}, Ze = /* @__PURE__ */ l("span", { class: "fas fa-info-circle" }, null, -1), Xe = {
  key: 2,
  class: "error clear-background"
}, xe = {
  key: 3,
  class: "success clear-background fas fa-check-circle"
}, et = { key: 1 }, tt = ["disabled", "name", "height", "id", "readonly", "required", "multiple", "width", "data-error-message-value-missing"], at = ["value", "selected"];
function nt(e, t, a, n, o, c) {
  return r(), s("div", null, [
    e.showLabel && e.internalSchema.displayName ? (r(), s("label", {
      key: 0,
      for: e.getFieldID()
    }, [
      p(h(e.internalSchema.displayName) + " ", 1),
      e.internalSchema.metadata.required && e.errorMessage ? (r(), s("span", Je, "*")) : d("", !0),
      e.internalSchema.metadata.hint ? (r(), s("i", We, [
        Ze,
        p(h(e.internalSchema.metadata.hint), 1)
      ])) : d("", !0),
      e.errorMessage ? (r(), s("span", Xe, h(e.errorMessage), 1)) : d("", !0),
      !e.errorMessage && e.willValidate() ? (r(), s("span", xe)) : d("", !0)
    ], 8, Qe)) : d("", !0),
    e.internalSchema.metadata.subtitle ? (r(), s("div", et, h(e.internalSchema.metadata.subtitle), 1)) : d("", !0),
    j(l("select", {
      "onUpdate:modelValue": t[0] || (t[0] = (i) => e.internalModel = i),
      disabled: e.internalSchema.metadata.disabled,
      name: e.internalSchema.metadata.inputName || e.getFieldID(),
      height: e.internalSchema.metadata.height,
      id: e.getFieldID(),
      onChange: t[1] || (t[1] = (i) => e.changed(e.internalModel)),
      readonly: e.internalSchema.metadata.readonly,
      required: e.internalSchema.metadata.required,
      multiple: e.internalSchema.metadata.multiple,
      class: v(e.internalSchema.metadata.inputClasses),
      width: e.internalSchema.metadata.width,
      "data-error-message-value-missing": e.internalSchema.metadata.errorMessageValueMissing
    }, [
      (r(!0), s(b, null, S(e.internalSchema.metadata.options, (i) => (r(), s("option", {
        value: i.key,
        selected: e.isSelected(i),
        key: i.key
      }, h(i.value), 9, at))), 128))
    ], 42, tt), [
      [ne, e.internalModel]
    ])
  ]);
}
const se = /* @__PURE__ */ $(He, [["render", nt]]), it = y.defineComponent({
  name: "form-field-checkbox",
  data: function() {
    return {
      internalModel: this.model,
      internalSchema: this.schema,
      errorMessage: ""
    };
  },
  props: {
    model: {
      type: Boolean,
      required: !0,
      default: !1
    },
    schema: {
      type: F,
      required: !0,
      default: () => new F()
    },
    showLabel: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  methods: {
    // determines if the field will be validated
    willValidate: function() {
      return this.internalSchema.metadata.required;
    },
    // revalidate the input field
    revalidate: async function() {
      let e = document.getElementById(this.getFieldID());
      if (e == null)
        return;
      let t = await new L().validate(e);
      return this.errorMessage = t.errorMessage, t.isValid;
    },
    // gets the field id
    getFieldID: function() {
      return this.internalSchema.propertyName.slugify() + this.internalSchema.key;
    },
    // called when the value changes
    // newValue: the new value
    // emits the changed event
    changed: function(e) {
      this.revalidate(), this.$emit("changed", e, this.schema);
    }
  },
  watch: {
    // watches the model for changes
    // newModel: the new model
    // oldModel: the old model
    model: function(e, t) {
      t !== e && (this.internalModel = e, this.$nextTick(function() {
        this.revalidate();
      }));
    },
    // watches the schema for changes
    // newSchema: the new schema
    // oldSchema: the old schema
    schema: function(e, t) {
      t !== e && (this.internalSchema = e, this.$nextTick(function() {
        this.revalidate();
      }));
    }
  },
  // mounted event handler, revalidates the field
  mounted: function() {
    this.$nextTick(function() {
      this.revalidate();
    });
  }
}), rt = ["for"], st = { key: 0 }, ot = {
  key: 1,
  class: "error clear-background"
}, lt = {
  key: 2,
  class: "error clear-background"
}, dt = {
  key: 3,
  class: "success clear-background fas fa-check-circle"
}, ct = { key: 4 }, ut = ["id", "checked", "disabled", "dirname", "name", "readonly", "required"];
function ht(e, t, a, n, o, c) {
  return r(), s("div", null, [
    l("label", {
      for: e.getFieldID()
    }, [
      e.showLabel && e.internalSchema.displayName ? (r(), s("span", st, h(e.internalSchema.displayName), 1)) : d("", !0),
      e.internalSchema.metadata.required && e.errorMessage ? (r(), s("span", ot, "*")) : d("", !0),
      e.errorMessage ? (r(), s("span", lt, h(e.errorMessage), 1)) : d("", !0),
      !e.errorMessage && e.willValidate() ? (r(), s("span", dt)) : d("", !0),
      e.internalSchema.metadata.subtitle ? (r(), s("div", ct, h(e.internalSchema.metadata.subtitle), 1)) : d("", !0),
      l("input", {
        id: e.getFieldID(),
        type: "checkbox",
        checked: e.internalModel,
        onClick: t[0] || (t[0] = (i) => e.changed(i.target.checked)),
        disabled: e.internalSchema.metadata.disabled,
        dirname: e.internalSchema.metadata.dirname,
        name: e.getFieldID(),
        readonly: e.internalSchema.metadata.readonly,
        required: e.internalSchema.metadata.required
      }, null, 8, ut)
    ], 8, rt)
  ]);
}
const oe = /* @__PURE__ */ $(it, [["render", ht]]), mt = y.defineComponent({
  name: "form-field-radio",
  data: function() {
    return {
      internalModel: this.model,
      internalSchema: this.schema,
      optionsQuery: "query($queryType: String!) { dropDown(type: $queryType) { key, value } }",
      errorMessage: ""
    };
  },
  props: {
    model: {
      type: String,
      required: !0,
      default: ""
    },
    schema: {
      type: F,
      required: !0,
      default: () => new F()
    },
    showLabel: {
      type: Boolean,
      required: !1,
      default: !0
    }
  },
  methods: {
    // determines if the field will be validated
    willValidate: function() {
      return this.internalSchema.metadata.required;
    },
    // revalidate the input field
    revalidate: async function() {
      let e = await new J().validate(document.getElementById(this.getFieldID()));
      return this.errorMessage = e.errorMessage, e.isValid;
    },
    // gets the field id
    getFieldID: function() {
      if (this.internalSchema != null)
        return this.internalSchema.propertyName.slugify() + this.internalSchema.key;
    },
    // get the field name
    getFieldName: function() {
      return this.internalSchema.id ? this.internalSchema.id : this.internalSchema.propertyName.slugify();
    },
    // called when the value changes
    // emits the changed event
    // newValue: the new value
    changed: function(e) {
      this.revalidate(), this.$emit("changed", e, this.schema);
    },
    // Is the item checked?
    // item: item to check
    isItemChecked: function(e) {
      return e === this.internalModel;
    },
    // determines if the value is selected
    // value: the value to check
    isSelected: function(e) {
      return this.internalModel === e.key;
    },
    // gets the values for the select element
    getValues: async function() {
      if (!this.internalSchema.metadata.queryType)
        return;
      let e = this;
      f.debug("Select: Getting values for " + this.internalSchema.metadata.queryType), await k.post("/api/query", {
        query: e.optionsQuery,
        variables: {
          queryType: e.internalSchema.metadata.queryType
        }
      }).onSuccess((t) => {
        f.debug("Select: " + e.internalSchema.metadata.queryType + " loaded successfully.", t.data.dropDown), e.internalSchema.metadata.options = t.data.dropDown;
      }).onError((t) => {
        f.error("Select: " + e.internalSchema.metadata.queryType + " failed to load.", t);
      }).withStorageMode(V.StorageAndUpdate).send();
    }
  },
  // created event, gets the values for the select element
  created: function() {
    this.getValues();
  },
  watch: {
    // watches the model and revalidates when it changes
    // newModel: the new model
    // oldModel: the old model
    model: function(e, t) {
      t !== e && (this.internalModel = e, this.$nextTick(function() {
        this.revalidate();
      }));
    },
    // watches the schema and revalidates when it changes
    // newSchema: the new schema
    // oldSchema: the old schema
    schema: function(e, t) {
      t !== e && (this.internalSchema = e, this.$nextTick(function() {
        this.revalidate();
      }));
    }
  },
  // mounted event, revalidates the field
  mounted: function() {
    this.$nextTick(function() {
      this.revalidate();
    });
  }
}), ft = ["for"], pt = {
  key: 0,
  class: "error clear-background"
}, gt = {
  key: 1,
  class: "clear-background active no-border small"
}, yt = /* @__PURE__ */ l("span", { class: "fas fa-info-circle" }, null, -1), bt = {
  key: 2,
  class: "error clear-background"
}, St = {
  key: 3,
  class: "success clear-background fas fa-check-circle"
}, $t = { key: 1 }, vt = { class: "flex row text-center" }, kt = ["id", "checked", "onClick", "disabled", "name", "readonly", "value"];
function wt(e, t, a, n, o, c) {
  return r(), s("div", null, [
    e.showLabel && e.internalSchema.displayName ? (r(), s("label", {
      key: 0,
      for: e.getFieldID()
    }, [
      p(h(e.internalSchema.displayName) + " ", 1),
      e.internalSchema.metadata.required && e.errorMessage ? (r(), s("span", pt, "*")) : d("", !0),
      e.internalSchema.metadata.hint ? (r(), s("i", gt, [
        yt,
        p(h(e.internalSchema.metadata.hint), 1)
      ])) : d("", !0),
      e.errorMessage ? (r(), s("span", bt, h(e.errorMessage), 1)) : d("", !0),
      !e.errorMessage && e.willValidate() ? (r(), s("span", St)) : d("", !0)
    ], 8, ft)) : d("", !0),
    e.internalSchema.metadata.subtitle ? (r(), s("div", $t, h(e.internalSchema.metadata.subtitle), 1)) : d("", !0),
    l("div", vt, [
      (r(!0), s(b, null, S(e.internalSchema.metadata.options, (i) => (r(), s("div", {
        key: i.key
      }, [
        l("label", null, [
          l("input", {
            id: e.getFieldID(i.key),
            type: "radio",
            checked: e.isItemChecked(i.key),
            onClick: (u) => e.changed(i.key),
            disabled: e.internalSchema.metadata.disabled,
            name: e.internalSchema.metadata.inputName || e.getFieldName(),
            readonly: e.internalSchema.metadata.readonly,
            class: v(e.internalSchema.metadata.inputClasses),
            value: i.key
          }, null, 10, kt),
          p(" " + h(e.$filters.capitalize(i.value)), 1)
        ])
      ]))), 128))
    ])
  ]);
}
const le = /* @__PURE__ */ $(mt, [["render", wt]]), Mt = y.defineComponent({
  data: function() {
    return {
      internalModel: this.model,
      errorMessage: ""
    };
  },
  props: {
    model: Object,
    schema: Object,
    idSuffix: String,
    label: {
      default: !0,
      type: Boolean
    }
  },
  computed: {
    charactersRemaining: function() {
      return this.internalModel == null ? 0 : this.schema.maxlength - this.internalModel.length;
    }
  },
  methods: {
    willValidate: function() {
      return this.internalSchema.metadata.required || this.internalSchema.metadata.maxlength || this.internalSchema.metadata.minlength || this.internalSchema.metadata.pattern || this.internalSchema.metadata.min || this.internalSchema.metadata.max;
    },
    revalidate: async function() {
      let e = await new L().validate(document.getElementById(this.getFieldID()));
      return this.errorMessage = e.errorMessage, e.isValid;
    },
    getFieldID: function() {
      let e = "";
      return this.schema.id ? e = this.schema.id : e = this.schema.model.slugify(), this.idSuffix !== void 0 && (e += this.idSuffix), e;
    },
    changed: function(e) {
      this.revalidate(), this.$emit("changed", e, this.schema);
    }
  },
  watch: {
    model: function(e, t) {
      t !== e && (this.internalModel = e, this.$nextTick(function() {
        this.revalidate();
      }));
    }
  },
  mounted: function() {
    this.$nextTick(function() {
      this.revalidate();
    });
  }
}), Dt = ["for"], Et = {
  key: 0,
  class: "error clear-background"
}, Tt = {
  key: 1,
  class: "clear-background active no-border small"
}, Ct = /* @__PURE__ */ l("span", { class: "fas fa-info-circle" }, null, -1), Ft = {
  key: 2,
  class: "error clear-background"
}, qt = {
  key: 3,
  class: "success clear-background fas fa-check-circle"
}, It = ["for"], jt = {
  key: 0,
  class: "error clear-background"
}, Vt = {
  key: 1,
  class: "clear-background active no-border small"
}, At = /* @__PURE__ */ l("span", { class: "fas fa-info-circle" }, null, -1), Ot = {
  key: 2,
  class: "error clear-background"
}, Nt = {
  key: 3,
  class: "success clear-background fas fa-check-circle"
}, Lt = { key: 2 }, Pt = ["id", "disabled", "height", "maxlength", "minlength", "name", "placeholder", "title", "readonly", "required", "width", "rows", "data-error-message-value-missing", "data-error-message-too-long", "data-error-message-too-short"], Bt = {
  key: 3,
  class: "clear-background active right small"
}, Rt = /* @__PURE__ */ l("span", { class: "fas fa-info-circle" }, null, -1), zt = /* @__PURE__ */ l("br", { class: "clear" }, null, -1);
function Ut(e, t, a, n, o, c) {
  return r(), s("div", null, [
    p(" Text Area "),
    !e.schema.label && e.label ? (r(), s("label", {
      key: 0,
      for: e.getFieldID(),
      class: v(e.schema.labelClasses)
    }, [
      p(h(e.$filters.capitalize(e.schema.model)) + " ", 1),
      e.schema.required && e.errorMessage ? (r(), s("span", Et, "*")) : d("", !0),
      e.schema.hint ? (r(), s("i", Tt, [
        Ct,
        p(h(e.schema.hint), 1)
      ])) : d("", !0),
      e.errorMessage ? (r(), s("span", Ft, h(e.errorMessage), 1)) : d("", !0),
      !e.errorMessage && e.willValidate() ? (r(), s("span", qt)) : d("", !0)
    ], 10, Dt)) : d("", !0),
    e.schema.label && e.label ? (r(), s("label", {
      key: 1,
      for: e.getFieldID(),
      class: v(e.schema.labelClasses)
    }, [
      p(h(e.schema.label) + " ", 1),
      e.schema.required && e.errorMessage ? (r(), s("span", jt, "*")) : d("", !0),
      e.schema.hint ? (r(), s("i", Vt, [
        At,
        p(h(e.schema.hint), 1)
      ])) : d("", !0),
      e.errorMessage ? (r(), s("span", Ot, h(e.errorMessage), 1)) : d("", !0),
      !e.errorMessage && e.willValidate() ? (r(), s("span", Nt)) : d("", !0)
    ], 10, It)) : d("", !0),
    e.internalSchema.metadata.subtitle ? (r(), s("div", Lt, h(e.internalSchema.metadata.subtitle), 1)) : d("", !0),
    j(l("textarea", {
      id: e.getFieldID(),
      "onUpdate:modelValue": t[0] || (t[0] = (i) => e.internalModel = i),
      onInput: t[1] || (t[1] = (i) => e.changed(i.target.value)),
      disabled: e.schema.disabled,
      height: e.schema.height,
      maxlength: e.schema.maxlength,
      minlength: e.schema.minlength,
      name: e.schema.inputName || e.getFieldID(),
      placeholder: e.schema.placeholder,
      title: e.schema.placeholder,
      readonly: e.schema.readonly,
      class: v(e.schema.inputClasses),
      required: e.schema.required,
      width: e.schema.width,
      rows: e.schema.rows || 3,
      "data-error-message-value-missing": e.schema.errorMessageValueMissing,
      "data-error-message-too-long": e.schema.errorMessageTooLong,
      "data-error-message-too-short": e.schema.errorMessageTooShort
    }, `\r
        `, 42, Pt), [
      [ie, e.internalModel]
    ]),
    e.schema.maxlength ? (r(), s("div", Bt, [
      Rt,
      p(" " + h(e.charactersRemaining) + " characters remaining (" + h(e.schema.maxlength) + " max) ", 1)
    ])) : d("", !0),
    zt
  ]);
}
const de = /* @__PURE__ */ $(Mt, [["render", Ut]]), Yt = y.defineComponent({
  data: function() {
    return {
      internalModel: this.model
    };
  },
  props: {
    model: Object,
    schema: Object,
    idSuffix: String
  },
  methods: {},
  watch: {
    model: function(e, t) {
      t !== e && (this.internalModel = e);
    }
  }
}), _t = ["innerHTML"];
function Kt(e, t, a, n, o, c) {
  return r(), s("div", null, [
    p(" Text "),
    l("div", {
      class: v(e.schema.classes),
      innerHTML: e.internalModel || e.schema.model
    }, null, 10, _t)
  ]);
}
const ce = /* @__PURE__ */ $(Yt, [["render", Kt]]), Gt = y.defineComponent({
  data() {
    return {
      files: [],
      ready: !1,
      filesAdded: 0,
      internalModel: this.model,
      errorMessage: ""
    };
  },
  props: {
    model: Object,
    schema: Object,
    idSuffix: String
  },
  methods: {
    willValidate: function() {
      return this.internalSchema.metadata.required || this.internalSchema.metadata.maxlength || this.internalSchema.metadata.minlength || this.internalSchema.metadata.pattern || this.internalSchema.metadata.min || this.internalSchema.metadata.max;
    },
    revalidate: async function() {
      let e = await new L().validate(document.getElementById(this.getFieldID()));
      return this.errorMessage = e.errorMessage, e.isValid;
    },
    getFieldID: function() {
      let e = "";
      return this.schema.id ? e = this.schema.id : e = this.schema.model.slugify(), this.idSuffix !== void 0 && (e += this.idSuffix), e;
    },
    changed: function(e) {
      this.revalidate();
      let t = this;
      t.filesAdded = t.filesAdded + e.target.files.length, t.ready = !1;
      for (let a = 0; a < e.target.files.length; ++a) {
        let n = new FileReader();
        n.onload = function(o) {
          return function(c) {
            t.files = t.files.concat({ filename: o, data: t.base64ArrayBuffer(n.result) }), t.files.length === t.filesAdded && (t.ready = !0);
          };
        }(e.target.files[a].name), n.readAsArrayBuffer(e.target.files[a]);
      }
      this.check();
    },
    base64ArrayBuffer: function(e) {
      let t = "", a = new Uint8Array(e), n = a.byteLength;
      for (let o = 0; o < n; ++o)
        t += String.fromCharCode(a[o]);
      return window.btoa(t);
    },
    check: function() {
      if (this.ready === !0) {
        this.$emit("changed", this.files, this.schema);
        return;
      }
      setTimeout(this.check, 100);
    },
    removeFile: function(e) {
      let t = this.files.indexOf(e);
      this.files.splice(t, 1), this.filesAdded--;
    },
    generateGuid: function(e) {
      let t = e.key;
      if (t)
        return t;
      let a = "";
      for (let n = 0; n < 32; n++) {
        let o = Math.floor(Math.random() * 16).toString(16).toUpperCase();
        a = a + o;
      }
      return e.key = a, e.key;
    }
  },
  watch: {
    model: function(e, t) {
      t !== e && (this.internalModel = e, this.$nextTick(function() {
        this.revalidate();
      }));
    }
  },
  mounted: function() {
    this.$nextTick(function() {
      this.revalidate();
    });
  }
}), Ht = ["for"], Qt = {
  key: 0,
  class: "error clear-background"
}, Jt = {
  key: 1,
  class: "clear-background active no-border small"
}, Wt = /* @__PURE__ */ l("span", { class: "fas fa-info-circle" }, null, -1), Zt = {
  key: 2,
  class: "error clear-background"
}, Xt = {
  key: 3,
  class: "success clear-background fas fa-check-circle"
}, xt = ["for"], ea = {
  key: 0,
  class: "error clear-background"
}, ta = {
  key: 1,
  class: "clear-background active no-border small"
}, aa = /* @__PURE__ */ l("span", { class: "fas fa-info-circle" }, null, -1), na = {
  key: 2,
  class: "error clear-background"
}, ia = {
  key: 3,
  class: "success clear-background fas fa-check-circle"
}, ra = { key: 2 }, sa = ["accept", "id", "multiple", "name", "required", "data-error-message-value-missing"], oa = {
  key: 3,
  class: "flex"
}, la = ["onClick"], da = { class: "body" };
function ca(e, t, a, n, o, c) {
  return r(), s("div", null, [
    p(" Upload "),
    e.schema.label ? d("", !0) : (r(), s("label", {
      key: 0,
      for: e.getFieldID(),
      class: v(e.schema.labelClasses)
    }, [
      p(h(e.$filters.capitalize(e.schema.model)) + " ", 1),
      e.schema.required && e.errorMessage ? (r(), s("span", Qt, "*")) : d("", !0),
      e.schema.hint ? (r(), s("i", Jt, [
        Wt,
        p(h(e.schema.hint), 1)
      ])) : d("", !0),
      e.errorMessage ? (r(), s("span", Zt, h(e.errorMessage), 1)) : d("", !0),
      !e.errorMessage && e.willValidate() ? (r(), s("span", Xt)) : d("", !0)
    ], 10, Ht)),
    e.schema.label ? (r(), s("label", {
      key: 1,
      for: e.getFieldID(),
      class: v(e.schema.labelClasses)
    }, [
      p(h(e.schema.label) + " ", 1),
      e.schema.required && e.errorMessage ? (r(), s("span", ea, "*")) : d("", !0),
      e.schema.hint ? (r(), s("i", ta, [
        aa,
        p(h(e.schema.hint), 1)
      ])) : d("", !0),
      e.errorMessage ? (r(), s("span", na, h(e.errorMessage), 1)) : d("", !0),
      !e.errorMessage && e.willValidate() ? (r(), s("span", ia)) : d("", !0)
    ], 10, xt)) : d("", !0),
    e.internalSchema.metadata.subtitle ? (r(), s("div", ra, h(e.internalSchema.metadata.subtitle), 1)) : d("", !0),
    l("div", {
      class: v(["file-upload", e.schema.inputClasses])
    }, [
      p(h(e.schema.placeholder) + " ", 1),
      l("input", {
        accept: e.schema.accept,
        id: e.getFieldID(),
        onChange: t[0] || (t[0] = (i) => e.changed(i)),
        multiple: e.schema.multiple,
        name: e.schema.inputName || e.getFieldID(),
        required: e.schema.required,
        type: "file",
        "data-error-message-value-missing": e.schema.errorMessageValueMissing
      }, null, 40, sa)
    ], 2),
    e.schema.uploadPreview ? (r(), s("div", oa, [
      (r(!0), s(b, null, S(e.files, (i) => (r(), s("div", {
        class: v(["upload-preview panel", e.schema.previewClasses]),
        key: e.generateGuid(i)
      }, [
        l("header", null, [
          l("div", {
            class: "header",
            onClick: (u) => e.removeFile(i)
          }, "", 8, la),
          p("")
        ]),
        l("div", da, h(i.filename), 1)
      ], 2))), 128))
    ])) : d("", !0)
  ]);
}
const ue = /* @__PURE__ */ $(Gt, [["render", ca]]), ua = y.defineComponent({
  data: function() {
    return {
      internalModel: this.model
    };
  },
  props: {
    model: Object,
    schema: Object,
    idSuffix: String
  },
  methods: {
    click: function(e, t) {
      return this.$emit("click", e, t), !1;
    },
    generateGuid: function(e) {
      let t = e.key;
      if (t)
        return t;
      let a = "";
      for (let n = 0; n < 32; n++) {
        let o = Math.floor(Math.random() * 16).toString(16).toUpperCase();
        a = a + o;
      }
      return e.key = a, e.key;
    }
  },
  watch: {
    model: function(e, t) {
      t !== e && (this.internalModel = e);
    }
  }
}), ha = { class: "controls" }, ma = { class: "input-group" }, fa = ["type", "value", "onClick"];
function pa(e, t, a, n, o, c) {
  return r(), s("div", ha, [
    p(" Buttons "),
    l("div", ma, [
      (r(!0), s(b, null, S(e.schema.buttons, (i) => (r(), s("input", {
        key: e.generateGuid(i),
        type: i.type,
        value: i.value,
        class: v(i.classes),
        onClick: (u) => e.click(u, i)
      }, null, 10, fa))), 128))
    ])
  ]);
}
const he = /* @__PURE__ */ $(ua, [["render", pa]]), ga = y.defineComponent({
  data: function() {
    return {
      internalModel: this.model
    };
  },
  props: {
    model: Object,
    schema: Object,
    idSuffix: String
  },
  methods: {
    show: function(e) {
      return typeof e == "function" ? e() : e;
    },
    getFieldType: function(e) {
      return e.type.indexOf("form-field-") == 0 ? e.type : "form-field-" + e.type;
    },
    getModelValue: function(e) {
      return this.internalModel[e.model];
    },
    error: function(e) {
      this.$emit("error", e);
    },
    exception: function(e) {
      this.$emit("exception", e);
    },
    setModelValue: function(e, t) {
      this.internalModel[t.model] = e, this.$emit("changed", this.internalModel, this.schema);
    },
    buttonClicked: function(e, t) {
      this.$emit("click", e, t);
    },
    getSchema: function(e) {
      return e.type.startsWith("complex") ? (e.schema.model === void 0 && (e.schema.model = e.model), e.schema) : e;
    },
    getIDSuffix: function(e) {
      return this.idSuffix === void 0 ? "" : this.idSuffix;
    },
    generateGuid: function(e) {
      let t = e.key;
      if (t)
        return t;
      let a = "";
      for (let n = 0; n < 32; n++) {
        let o = Math.floor(Math.random() * 16).toString(16).toUpperCase();
        a = a + o;
      }
      return e.key = a, e.key;
    }
  },
  watch: {
    model: function(e, t) {
      t !== e && (this.internalModel = e);
    }
  }
}), ya = { key: 0 };
function ba(e, t, a, n, o, c) {
  return r(), s("div", null, [
    p(" Conditional "),
    e.show(e.internalModel.display || e.schema.display) ? (r(), s("div", ya, [
      (r(!0), s(b, null, S(e.schema.fields, (i) => (r(), s("div", {
        key: e.generateGuid(i)
      }, [
        (r(), q(I(e.getFieldType(i)), {
          schema: e.getSchema(i),
          model: e.getModelValue(i),
          "id-suffix": e.getIDSuffix(i),
          onChanged: e.setModelValue,
          onClick: e.buttonClicked,
          onError: e.error,
          onException: e.exception
        }, null, 40, ["schema", "model", "id-suffix", "onChanged", "onClick", "onError", "onException"]))
      ]))), 128))
    ])) : d("", !0)
  ]);
}
const Sa = /* @__PURE__ */ $(ga, [["render", ba]]), $a = y.defineComponent({
  name: "form-field-complex-list",
  components: {
    "form-field-input": re,
    "form-field-select": se,
    "form-field-checkbox": oe,
    "form-field-radio": le,
    "form-field-text-area": de,
    "form-field-text": ce,
    "form-field-upload": ue,
    "form-field-buttons": he
  },
  data: function() {
    return {
      internalModel: this.model,
      internalSchema: this.schema,
      defaultItem: this.getDefaultValue(this.schema)
    };
  },
  props: {
    model: {
      type: Object,
      default: {}
    },
    schema: {
      type: Object,
      default: {
        fields: []
      }
    }
  },
  methods: {
    // Gets the default value for an item in the list based on the schema
    // schema: The schema to get the default value for
    getDefaultValue(e) {
      if (e == null)
        return {};
      let t = {};
      for (let a = 0; a < e.metadata.fields.length; ++a) {
        let n = e.metadata.fields[a];
        if (n.propertyType.indexOf("complex") == -1)
          if (n.metadata.inputType === "date" || n.metadata.inputType === "datetime-local" || n.metadata.inputType === "datetime" || n.metadata.inputType === "month") {
            let o = moment(/* @__PURE__ */ new Date());
            n.isUTC && (o = moment.utc(/* @__PURE__ */ new Date()).local()), n.inputType === "date" ? t[n.propertyName] = o.format("YYYY-MM-DD") : n.inputType === "datetime-local" || n.inputType === "datetime" ? t[n.propertyName] = o.format("YYYY-MM-DDTHH:mm") : n.inputType === "month" && (t[n.propertyName] = o.format("YYYY-MM"));
          } else
            t[n.propertyName] = "";
        else
          n.propertyType.indexOf("complex-list") > -1 || n.propertyType.indexOf("complex-repeater") > -1 ? t[n.propertyName] = [] : t[n.propertyName] = this.getDefaultValue(n);
      }
      return t;
    },
    // Gets the field type for a given field
    // field: The field to get the type for
    getFieldType: function(e) {
      return "form-field-" + e.propertyType;
    },
    // Gets the model value for a given field and item
    // field: The field to get the value for
    // item: The item to get the value for
    getModelValue: function(e, t) {
      return t[e.propertyName];
    },
    // Sets the model value for a given field and item
    // Emits the changed event
    // field: The field to set the value for
    // item: The item to set the value for
    // newValue: The new value to set
    setModelValue: function(e, t, a) {
      t[e.propertyName] = a, this.$emit("changed", this.internalModel, this.schema);
    },
    // Emits the error event
    error: function(e) {
      this.$emit("error", e);
    },
    // Emits the exception event
    exception: function(e) {
      this.$emit("exception", e);
    },
    // Emits the click event when a button is clicked
    buttonClicked: function(e, t) {
      this.$emit("click", e, t);
    },
    // Removes an item from the list
    // item: The item to remove
    removeItem: function(e) {
      if (this.internalSchema.confirmRemoval && !confirm("Are you sure you want to remove this item?"))
        return;
      this.internalModel || (this.internalModel = []);
      let t = this.internalModel.indexOf(e);
      this.internalModel.splice(t, 1), this.$emit("changed", this.internalModel, this.internalSchema);
    },
    // Adds an item to the list using the default value
    // Emits the changed event
    addItem: function() {
      this.internalModel || (this.internalModel = []), this.internalModel = this.internalModel.concat(Object.assign({}, this.defaultItem)), this.$emit("changed", this.internalModel, this.schema);
    },
    // Generates a guid for an item
    generateGuid: function(e) {
      let t = e.key;
      if (t)
        return t;
      let a = "";
      for (let n = 0; n < 32; n++) {
        let o = Math.floor(Math.random() * 16).toString(16).toUpperCase();
        a = a + o;
      }
      return e.key = a, e.key;
    }
  },
  watch: {
    // Watches for changes to the model and updates the internal model
    // newModel: The new model value
    // oldModel: The old model value
    model: function(e, t) {
      t !== e && (this.internalModel = e);
    },
    // Watches for changes to the schema and updates the internal schema
    // newSchema: The new schema value
    // oldSchema: The old schema value
    schema: function(e, t) {
      t !== e && (this.internalSchema = e);
    }
  }
}), va = { key: 0 }, ka = { class: "form-table" }, wa = ["data-tooltip"], Ma = /* @__PURE__ */ l("span", { class: "fas fa-info-circle no-border small" }, null, -1), Da = [
  Ma
], Ea = /* @__PURE__ */ l("th", null, null, -1), Ta = ["onClick"], Ca = ["colspan"], Fa = /* @__PURE__ */ l("span", { class: "fas fa-plus-circle" }, null, -1);
function qa(e, t, a, n, o, c) {
  return r(), s("div", null, [
    e.internalSchema.displayName ? (r(), s("h2", va, h(e.$filters.capitalize(e.internalSchema.displayName)), 1)) : d("", !0),
    l("table", ka, [
      l("thead", null, [
        l("tr", null, [
          (r(!0), s(b, null, S(e.internalSchema.metadata.fields, (i) => (r(), s("th", {
            key: e.generateGuid(i)
          }, [
            p(h(e.$filters.capitalize(i.displayName)) + " ", 1),
            i.metadata.hint ? (r(), s("span", {
              key: 0,
              "data-tooltip": i.metadata.hint,
              "data-tooltip-size": "extra-large"
            }, Da, 8, wa)) : d("", !0)
          ]))), 128)),
          Ea
        ])
      ]),
      l("tbody", null, [
        (r(!0), s(b, null, S(e.internalModel, (i, u) => (r(), s("tr", {
          key: e.generateGuid(i)
        }, [
          (r(!0), s(b, null, S(e.internalSchema.metadata.fields, (m) => (r(), s("td", {
            key: e.generateGuid(m)
          }, [
            (r(), q(I(e.getFieldType(m)), {
              schema: m,
              model: e.getModelValue(m, i),
              label: !1,
              onChanged: (g) => e.setModelValue(m, i, g),
              onClick: e.buttonClicked,
              onError: e.error,
              onException: e.exception
            }, null, 40, ["schema", "model", "onChanged", "onClick", "onError", "onException"]))
          ]))), 128)),
          l("td", null, [
            l("a", {
              class: "fas fa-minus-circle",
              onClick: C((m) => e.removeItem(i), ["stop", "prevent"])
            }, null, 8, Ta)
          ])
        ]))), 128))
      ]),
      l("tfoot", null, [
        l("tr", null, [
          l("td", {
            colspan: e.internalSchema.metadata.fields.length + 1
          }, [
            l("a", {
              onClick: t[0] || (t[0] = C((...i) => e.addItem && e.addItem(...i), ["stop", "prevent"]))
            }, [
              Fa,
              p("Add More")
            ])
          ], 8, Ca)
        ])
      ])
    ])
  ]);
}
const Ia = /* @__PURE__ */ $($a, [["render", qa]]), ja = y.defineComponent({
  methods: {
    findTab: function(e) {
      return !this.sections || this.sections.length === 0 ? null : (e || (e = this.sections[0].name), this.sections.filter((t) => t.name === e)[0]);
    },
    switchSelected: function(e) {
      this.sectionPicked = this.findTab(e), this.switchTabs(), this.$emit("section-changed", this.sectionPicked);
    },
    switchTabs: function() {
      if (!(!this.sections || this.sections.length === 0) && (this.sections.some((e) => e === this.sectionPicked) || (this.sectionPicked = this.sections[0]), !!this.sectionPicked)) {
        for (let e = 0; e < this.sections.length; ++e)
          this.sections[e].selected = !1;
        this.sectionPicked.selected = !0;
      }
    }
  },
  props: {
    initialSectionPicked: {
      type: String,
      default: ""
    },
    sections: {
      type: Array,
      default: []
    }
  },
  watch: {
    sections: function(e) {
      var t;
      this.switchSelected((t = this.sectionPicked) == null ? void 0 : t.name);
    },
    initialSectionPicked: function(e) {
      this.switchSelected(this.initialSectionPicked);
    }
  },
  data() {
    return {
      sectionPicked: this.findTab(this.initialSectionPicked)
    };
  },
  beforeMount: function() {
    this.switchSelected(this.initialSectionPicked);
  }
}), Va = { class: "tabs" }, Aa = { class: "row flex align-items-stretch" }, Oa = ["onClick"];
function Na(e, t, a, n, o, c) {
  return r(), s("div", Va, [
    l("header", null, [
      l("ul", Aa, [
        (r(!0), s(b, null, S(e.sections, (i, u) => (r(), s("li", { key: u }, [
          l("a", {
            href: "#!",
            onClick: C((m) => e.switchSelected(i.name), ["stop", "prevent"]),
            class: v(["tab", { selected: i.selected }])
          }, [
            l("span", {
              class: v(["fas", [i.icon]])
            }, null, 2),
            p(" " + h(i.name), 1)
          ], 10, Oa)
        ]))), 128))
      ])
    ]),
    l("section", null, [
      ke(e.$slots, "default")
    ])
  ]);
}
const La = /* @__PURE__ */ $(ja, [["render", Na]]), Pa = y.defineComponent({
  components: {
    tabs: La
  },
  data() {
    return {
      internalModel: this.model,
      tabPicked: this.schema.tabs[0]
    };
  },
  props: {
    model: Object,
    schema: Object,
    idSuffix: String
  },
  methods: {
    getFieldType: function(e) {
      return e.type.indexOf("form-field-") == 0 ? e.type : "form-field-" + e.type;
    },
    getModelValue: function(e) {
      return this.internalModel[this.tabPicked.model][e.model];
    },
    setModelValue: function(e, t) {
      this.internalModel[this.tabPicked.model][t.model] = e, this.$emit("changed", this.internalModel, this.schema);
    },
    error: function(e) {
      this.$emit("error", e);
    },
    exception: function(e) {
      this.$emit("exception", e);
    },
    buttonClicked: function(e, t) {
      this.$emit("click", e, t);
    },
    getSchema: function(e) {
      return e;
    },
    tabChanged: function(e) {
      this.tabPicked = e;
    },
    getFields: function() {
      return this.tabPicked.fields;
    },
    getIDSuffix: function(e) {
      return this.idSuffix === void 0 ? "" : this.idSuffix;
    },
    generateGuid: function(e) {
      let t = e.key;
      if (t)
        return t;
      let a = "";
      for (let n = 0; n < 32; n++) {
        let o = Math.floor(Math.random() * 16).toString(16).toUpperCase();
        a = a + o;
      }
      return e.key = a, e.key;
    }
  },
  watch: {
    model: function(e, t) {
      t !== e && (this.internalModel = e);
    }
  }
});
function Ba(e, t, a, n, o, c) {
  const i = O("tabs");
  return r(), s("div", null, [
    p(" Complex Tabs "),
    N(i, {
      sections: e.schema.tabs,
      onSectionChanged: e.tabChanged,
      class: v(e.schema.tabClasses)
    }, {
      default: we(() => [
        (r(!0), s(b, null, S(e.getFields(), (u) => (r(), s("div", {
          key: e.generateGuid(u)
        }, [
          (r(), q(I(e.getFieldType(u)), {
            schema: e.getSchema(u),
            model: e.getModelValue(u),
            "id-suffix": e.getIDSuffix(u),
            onChanged: e.setModelValue,
            onClick: e.buttonClicked,
            onError: e.error,
            onException: e.exception
          }, null, 40, ["schema", "model", "id-suffix", "onChanged", "onClick", "onError", "onException"]))
        ]))), 128))
      ]),
      _: 1
    }, 8, ["sections", "onSectionChanged", "class"])
  ]);
}
const Ra = /* @__PURE__ */ $(Pa, [["render", Ba]]), za = y.defineComponent({
  data: function() {
    let e = {};
    for (let t in this.model[0])
      this.model[0].hasOwnProperty(t) && (e[t] = "");
    return {
      internalModel: this.model,
      defaultItem: e
    };
  },
  props: {
    model: Object,
    schema: Object,
    idSuffix: String
  },
  methods: {
    getFieldType: function(e) {
      return e.type.indexOf("form-field-") == 0 ? e.type : "form-field-" + e.type;
    },
    getModelValue: function(e, t) {
      return t[e.model];
    },
    setModelValue: function(e, t, a) {
      t[e.model] = a, this.$emit("changed", this.internalModel, this.schema);
    },
    error: function(e) {
      this.$emit("error", e);
    },
    exception: function(e) {
      this.$emit("exception", e);
    },
    buttonClicked: function(e, t) {
      this.$emit("click", e, t);
    },
    getSchema: function(e) {
      return e;
    },
    removeItem: function(e) {
      if (this.schema.confirmRemoval && !confirm("Are you sure you want to remove this item?"))
        return;
      this.internalModel || (this.internalModel = []);
      let t = this.internalModel.indexOf(e);
      this.internalModel.splice(t, 1), this.$emit("changed", this.internalModel, this.schema);
    },
    addItem: function(e) {
      this.internalModel || (this.internalModel = []), this.internalModel = this.internalModel.concat(Object.assign({}, this.defaultItem)), this.$emit("changed", this.internalModel, this.schema);
    },
    getIDSuffix: function(e, t) {
      return this.idSuffix === void 0 ? t : this.idSuffix + t;
    },
    generateGuid: function(e) {
      let t = e.key;
      if (t)
        return t;
      let a = "";
      for (let n = 0; n < 32; n++) {
        let o = Math.floor(Math.random() * 16).toString(16).toUpperCase();
        a = a + o;
      }
      return e.key = a, e.key;
    }
  },
  watch: {
    model: function(e, t) {
      t !== e && (this.internalModel = e);
    }
  }
}), Ua = ["onClick"], Ya = /* @__PURE__ */ l("span", { class: "fas fa-plus-circle" }, null, -1);
function _a(e, t, a, n, o, c) {
  return r(), s("div", null, [
    p(" Complex Repeater "),
    (r(!0), s(b, null, S(e.internalModel, (i, u) => (r(), s("div", {
      key: e.generateGuid(i),
      class: "border-bottom"
    }, [
      l("a", {
        class: "fas fa-minus-circle right",
        onClick: C((m) => e.removeItem(i), ["stop", "prevent"])
      }, null, 8, Ua),
      (r(!0), s(b, null, S(e.schema.fields, (m) => (r(), s("div", {
        key: e.generateGuid(m)
      }, [
        (r(), q(I(e.getFieldType(m)), {
          schema: e.getSchema(m),
          model: e.getModelValue(m, i),
          label: !0,
          "id-suffix": e.getIDSuffix(m, u),
          onChanged: (g) => e.setModelValue(m, i, g),
          onClick: e.buttonClicked,
          onError: e.error,
          onException: e.exception
        }, null, 40, ["schema", "model", "id-suffix", "onChanged", "onClick", "onError", "onException"]))
      ]))), 128))
    ]))), 128)),
    l("a", {
      onClick: t[0] || (t[0] = C((...i) => e.addItem && e.addItem(...i), ["stop", "prevent"]))
    }, [
      Ya,
      p("Add More")
    ])
  ]);
}
const Ka = /* @__PURE__ */ $(za, [["render", _a]]), Ga = y.defineComponent({
  name: "form-field-complex",
  components: {
    "form-field-complex-conditional": Sa,
    "form-field-complex-list": Ia,
    "form-field-complex-tabs": Ra,
    "form-field-input": re,
    "form-field-select": se,
    "form-field-checkbox": oe,
    "form-field-radio": le,
    "form-field-text-area": de,
    "form-field-text": ce,
    "form-field-upload": ue,
    "form-field-buttons": he,
    "form-field-complex-repeater": Ka
  },
  data: function() {
    return {
      internalModel: this.model,
      internalSchema: this.schema
    };
  },
  props: {
    model: {
      type: Object,
      default: {}
    },
    schema: {
      type: Object,
      default: {
        fields: []
      }
    }
  },
  methods: {
    // When an error occurs, emit the error event
    // errorCode: contains the error code
    error: function(e) {
      this.$emit("error", e);
    },
    // When an exception occurs, emit the exception event
    // errorCode: contains the error code
    exception: function(e) {
      this.$emit("exception", e);
    },
    // When a field is changed, emit the changed event
    // newValue: contains the new value of the field
    // field: contains the field object
    setModelValue: function(e, t) {
      this.internalModel[t.propertyName] = e, this.$emit("changed", this.internalModel, this.schema);
    },
    // button clicked event
    // event: contains the event object
    // field: contains the field object
    buttonClicked: function(e, t) {
      this.$emit("click", e, t);
    },
    // generate a guid
    // item: contains the object
    generateGuid: function(e) {
      let t = e.key;
      if (t)
        return t;
      let a = "";
      for (let n = 0; n < 32; n++) {
        let o = Math.floor(Math.random() * 16).toString(16).toUpperCase();
        a = a + o;
      }
      return e.key = a, e.key;
    }
  },
  watch: {
    // watch for changes in the model
    // newModel: contains the new model
    // oldModel: contains the old model
    model: function(e, t) {
      t !== e && (this.internalModel = e);
    },
    // watch for changes in the schema
    // newSchema: contains the new schema
    // oldSchema: contains the old schema
    schema: function(e, t) {
      t !== e && (this.internalSchema = e);
    }
  }
});
function Ha(e, t, a, n, o, c) {
  return r(), s("div", null, [
    e.internalModel ? (r(!0), s(b, { key: 0 }, S(e.internalSchema.fields, (i) => (r(), s("div", {
      key: e.generateGuid(i)
    }, [
      (r(), q(I("form-field-" + i.propertyType), {
        schema: i,
        model: e.internalModel[i.propertyName],
        onChanged: e.setModelValue,
        onClick: e.buttonClicked,
        onError: e.error,
        onException: e.exception
      }, null, 40, ["schema", "model", "onChanged", "onClick", "onError", "onException"]))
    ]))), 128)) : d("", !0)
  ]);
}
const Qa = /* @__PURE__ */ $(Ga, [["render", Ha]]), Ja = y.defineComponent({
  name: "mithril-form",
  components: {
    "form-field-complex": Qa
  },
  data: function() {
    return {
      submitting: !1,
      internalModel: JSON.parse(JSON.stringify(this.model)),
      internalSchema: { fields: this.schema },
      formID: "mithril-form-" + Math.floor(Math.random() * 1e9),
      valid: !1
    };
  },
  props: {
    schema: {
      type: Array,
      default: []
    },
    model: {
      type: Object,
      default: {}
    },
    action: {
      default: "",
      type: String
    },
    ajaxAction: {
      default: "",
      type: String
    },
    encoding: {
      default: "multipart/form-data",
      type: String
    },
    debug: {
      default: !0,
      type: Boolean
    }
  },
  methods: {
    // revalidate the input field
    revalidate: async function() {
      return this.valid = await Ve.validateForm(document.getElementById(this.formID)), this.valid;
    },
    // set the model value and revalidate
    // newValue: the new value to set
    // field: the field to set
    setModelValue: function(e, t) {
      this.internalModel = e, this.revalidate(), this.$emit("changed", this.internalModel);
    },
    // emit an error event
    // errorCode: the error code to emit
    error: function(e) {
      this.$emit("error", e);
    },
    // emit an exception event
    // errorCode: the error code to emit
    exception: function(e) {
      this.$emit("exception", e);
    },
    // emit a click event on a button click
    // event: the event that was clicked
    // field: the field that was clicked
    buttonClicked: function(e, t) {
      this.revalidate(), this.$emit("click", e, t);
    },
    // reset the form to the original state and revalidate
    reset: function() {
      let e = this;
      f.debug("Resetting form to state:", e.model), e.internalModel = JSON.parse(JSON.stringify(e.model)), setTimeout(function() {
        e.revalidate();
      }, 100);
    },
    // submit the form to the server
    // event: the event that was submitted
    submit: function(e) {
      let t = this;
      return !t.revalidate() || t.submitting ? (e.preventDefault(), !1) : (t.submitting = !0, t.ajaxAction ? (f.debug("Submitting form to location: ", { location: t.ajaxAction }), k.post(t.ajaxAction, t.internalModel).onSuccess(function(a) {
        t.submitting = !1, t.$emit("success", a);
      }).onError(function(a) {
        t.submitting = !1, t.$emit("error", a);
      }).send(), e.preventDefault(), !1) : (this.$emit("submit", e, t.internalModel), e.preventDefault(), !1));
    },
    // get the ID suffix for the form
    getIDSuffix: function() {
      return "";
    }
  },
  watch: {
    // watch for changes to the schema
    // newSchema: the new schema
    // oldSchema: the old schema
    schema: function(e, t) {
      t !== e && (this.internalSchema = e, this.internalModel !== null && this.$nextTick(() => {
        this.revalidate();
      }));
    },
    // watch for changes to the model
    // newModel: the new model
    // oldModel: the old model
    model: function(e, t) {
      t !== e && (this.internalModel = e, e !== null && this.$nextTick(() => {
        this.revalidate();
      }));
    }
  },
  // mounted event handler for the component (revalidate the form)
  mounted: function() {
    this.$nextTick(function() {
      this.revalidate();
    });
  }
});
const U = (e) => (B("data-v-c5bd6270"), e = e(), R(), e), Wa = ["action", "enctype", "id"], Za = {
  key: 0,
  class: "panel error"
}, Xa = /* @__PURE__ */ U(() => /* @__PURE__ */ l("header", null, "Oops, some form elements have problems", -1)), xa = /* @__PURE__ */ U(() => /* @__PURE__ */ l("div", { class: "body" }, " We're sorry but some of the fields are having issues. ", -1)), en = [
  Xa,
  xa
], tn = { class: "input-group" }, an = ["disabled", "value"], nn = ["disabled"], rn = {
  key: 1,
  class: "flex row no-wrap"
}, sn = { class: "panel" }, on = /* @__PURE__ */ U(() => /* @__PURE__ */ l("header", null, "Form Schema", -1)), ln = { class: "body" }, dn = { class: "panel" }, cn = /* @__PURE__ */ U(() => /* @__PURE__ */ l("header", null, "Form Model", -1)), un = { class: "body" };
function hn(e, t, a, n, o, c) {
  const i = O("form-field-complex");
  return r(), s("form", {
    action: e.action,
    class: "stacked",
    onReset: t[0] || (t[0] = C((...u) => e.reset && e.reset(...u), ["stop", "prevent"])),
    onSubmit: t[1] || (t[1] = (...u) => e.submit && e.submit(...u)),
    method: "post",
    enctype: e.encoding,
    id: e.formID
  }, [
    e.valid ? d("", !0) : (r(), s("div", Za, en)),
    N(i, {
      schema: e.internalSchema,
      model: e.internalModel,
      onChanged: e.setModelValue,
      onClick: e.buttonClicked,
      onError: e.error,
      onException: e.exception
    }, null, 8, ["schema", "model", "onChanged", "onClick", "onError", "onException"]),
    l("div", null, [
      l("div", tn, [
        l("input", {
          type: "submit",
          disabled: e.submitting,
          value: e.submitting ? "Submitting..." : "Submit"
        }, null, 8, an),
        l("input", {
          type: "reset",
          disabled: e.submitting,
          value: "Reset"
        }, null, 8, nn)
      ])
    ]),
    e.debug ? (r(), s("div", rn, [
      l("div", sn, [
        on,
        l("div", ln, [
          l("pre", null, "                        " + h(e.internalSchema) + `
                    `, 1)
        ])
      ]),
      l("div", dn, [
        cn,
        l("div", un, [
          l("pre", null, "                        " + h(e.internalModel) + `
                    `, 1)
        ])
      ])
    ])) : d("", !0)
  ], 40, Wa);
}
const me = /* @__PURE__ */ $(Ja, [["render", hn], ["__scopeId", "data-v-c5bd6270"]]), mn = y.defineComponent({
  name: "settings-editor-component",
  components: {
    "mithril-form": me
  },
  data: function() {
    return {
      currentEntity: null,
      entityQuery: `query($entityType: String) {
                    entity(entityType: $entityType)
                }`
    };
  },
  methods: {
    // close the settings editor
    close: function() {
      this.$emit("close");
    },
    // load the entity
    loadData: z(async function() {
      let e = this;
      await k.post("/api/query", {
        query: e.entityQuery,
        variables: {
          entityType: e.schema.dataType
        }
      }).onSuccess((a) => {
        f.debug("Entity loaded successfully", a.data.entity), e.currentEntity = a.data.entity;
      }).send();
    }, 100),
    // save the entity
    // event: the event that triggered the save
    // entity: the entity to save
    saveEntity: function(e, t) {
      let a = this;
      if (e.preventDefault(), t != null)
        return this.currentEntity = null, f.debug(t), k.post("/api/command/v1/SaveModelCommand", {
          data: t,
          entityType: a.schema.dataType,
          id: t.iD
        }).onSuccess((n) => {
          f.debug("Entity saved successfully", n.data), a.close();
        }).onError((n) => {
          f.error("Error saving entity", n.data);
        }).send(), !1;
    }
  },
  props: {
    name: {
      type: String,
      default: ""
    },
    schema: {
      type: Object,
      default: {}
    },
    debug: {
      type: Boolean,
      default: !0
    }
  },
  // created event handler (load the entity)
  created: function() {
    this.loadData();
  },
  watch: {
    schema: function() {
      this.loadData();
    }
  }
}), fn = { class: "body" }, pn = {
  key: 0,
  class: "panel debug"
}, gn = /* @__PURE__ */ l("header", null, "Editor Schema", -1);
function yn(e, t, a, n, o, c) {
  const i = O("mithril-form");
  return r(), s("div", {
    class: v(["panel", e.schema.class])
  }, [
    l("header", null, h(e.name), 1),
    l("div", fn, [
      l("div", null, [
        N(i, {
          schema: e.schema.modelSchema,
          model: e.currentEntity,
          debug: e.debug,
          onSubmit: e.saveEntity
        }, null, 8, ["schema", "model", "debug", "onSubmit"])
      ]),
      e.debug && e.schema ? (r(), s("div", pn, [
        gn,
        l("pre", null, "" + h(e.schema) + `
            `, 1)
      ])) : d("", !0)
    ])
  ], 2);
}
const bn = /* @__PURE__ */ $(mn, [["render", yn]]);
class fe {
  // Constructor
  constructor(t, a, n, o, c) {
    this.filter = t, this.pageSize = a, this.page = n, this.sortField = o, this.sortAscending = c;
  }
}
const Sn = y.defineComponent({
  name: "mithril-listing",
  data: function() {
    return {
      internalModel: this.model,
      internalSchema: this.schema.filter((e) => {
        var t;
        return ((t = e.metadata) == null ? void 0 : t.canList) ?? !0;
      }),
      filter: "",
      pageSize: 10,
      page: 0,
      sortField: "",
      sortAscending: !1
    };
  },
  props: {
    model: {
      type: Object,
      default: {}
    },
    schema: {
      type: Array,
      default: []
    },
    debug: {
      type: Boolean,
      default: !1
    }
  },
  methods: {
    // filter data event is being raised
    filterData: z(function(e) {
      let t = this;
      t.$emit("filter", e, new fe(t.filter, t.pageSize, t.page, t.sortField, t.sortAscending));
    }, 300),
    // entity selected event is being raised
    // entity: the entity that was selected
    entitySelected: function(e) {
      this.$emit("entity-selected", e);
    }
  },
  watch: {
    // model changed
    // newModel: the new model
    // oldModel: the old model
    model: function(e, t) {
      t !== e && (this.internalModel = e);
    },
    // schema changed
    // newSchema: the new schema
    // oldSchema: the old schema
    schema: function(e, t) {
      t !== e && (this.internalSchema = e.filter((a) => {
        var n;
        return ((n = a.metadata) == null ? void 0 : n.canList) ?? !0;
      }));
    }
  }
});
const W = (e) => (B("data-v-f557b045"), e = e(), R(), e), $n = { class: "flex row" }, vn = { class: "right" }, kn = /* @__PURE__ */ Me('<option value="10" data-v-f557b045>10</option><option value="25" data-v-f557b045>25</option><option value="50" data-v-f557b045>50</option><option value="100" data-v-f557b045>100</option><option value="-1" data-v-f557b045>All</option>', 5), wn = [
  kn
], Mn = /* @__PURE__ */ W(() => /* @__PURE__ */ l("br", { class: "clear" }, null, -1)), Dn = ["onClick"], En = {
  key: 0,
  class: "flex row"
}, Tn = { class: "panel" }, Cn = /* @__PURE__ */ W(() => /* @__PURE__ */ l("header", null, "Listing Schema", -1)), Fn = { class: "body" }, qn = { class: "panel" }, In = /* @__PURE__ */ W(() => /* @__PURE__ */ l("header", null, "Listing Model", -1)), jn = { class: "body" };
function Vn(e, t, a, n, o, c) {
  return r(), s("div", null, [
    l("div", $n, [
      j(l("input", {
        type: "text",
        placeholder: "Find an item",
        onKeyup: t[0] || (t[0] = (...i) => e.filterData && e.filterData(...i)),
        "onUpdate:modelValue": t[1] || (t[1] = (i) => e.filter = i)
      }, null, 544), [
        [ie, e.filter]
      ]),
      l("div", null, [
        l("label", vn, [
          p(" Show "),
          j(l("select", {
            "onUpdate:modelValue": t[2] || (t[2] = (i) => e.pageSize = i),
            onChange: t[3] || (t[3] = (...i) => e.filterData && e.filterData(...i))
          }, wn, 544), [
            [ne, e.pageSize]
          ]),
          p(" Records ")
        ])
      ])
    ]),
    Mn,
    l("table", null, [
      l("thead", null, [
        l("tr", null, [
          (r(!0), s(b, null, S(e.internalSchema, (i) => (r(), s("th", {
            key: i.propertyName
          }, h(i.displayName), 1))), 128))
        ])
      ]),
      l("tbody", null, [
        (r(!0), s(b, null, S(e.internalModel, (i) => (r(), s("tr", {
          key: i.id
        }, [
          (r(!0), s(b, null, S(e.internalSchema, (u) => (r(), s("td", {
            key: u.propertyName
          }, [
            l("a", {
              onClick: (m) => e.entitySelected(i)
            }, h(i[u.propertyName]), 9, Dn)
          ]))), 128))
        ]))), 128))
      ])
    ]),
    e.debug ? (r(), s("div", En, [
      l("div", Tn, [
        Cn,
        l("div", Fn, [
          l("pre", null, "                        " + h(e.internalSchema) + `
                    `, 1)
        ])
      ]),
      l("div", qn, [
        In,
        l("div", jn, [
          l("pre", null, "                        " + h(e.internalModel) + `
                    `, 1)
        ])
      ])
    ])) : d("", !0)
  ]);
}
const An = /* @__PURE__ */ $(Sn, [["render", Vn], ["__scopeId", "data-v-f557b045"]]), On = y.defineComponent({
  name: "data-editor-component",
  components: {
    listing: An,
    "mithril-form": me
  },
  data: function() {
    return {
      entities: [],
      mode: "listing",
      currentEntity: null,
      entitiesQuery: `query($entityType: String, $pageSize: Int, $page: Int, $sortField: String, $sortAscending: Boolean, $filter: String) {
                    entities(entityType: $entityType, pageSize: $pageSize, page: $page, sortField: $sortField, sortAscending: $sortAscending, filter: $filter)
                }`,
      currentFilter: new fe("", 10, 0, "", !1),
      currentRequest: null,
      entityQuery: `query($entityType: String, $id: Long) {
                    entity(entityType: $entityType, id: $id)
                }`
    };
  },
  methods: {
    // edits an entity
    // entity: the entity to edit
    editEntity: async function(e) {
      let t = this;
      f.debug("Editing entity", e), await k.post("/api/query", {
        query: t.entityQuery,
        variables: {
          entityType: t.schema.dataType,
          id: e.iD
        }
      }).onSuccess((n) => {
        f.debug("Entity loaded successfully", n.data.entity), t.currentEntity = n.data.entity, this.mode = "editor";
      }).send();
    },
    // filter event handler
    // event: the event that triggered the filter
    // filter: the filter event
    filter: function(e, t) {
      this.currentFilter = t, this.loadData();
    },
    // loads the data
    loadData: z(async function() {
      let e = this;
      e.currentRequest != null && (e.cancellationToken.canceled = !0), e.cancellationToken = new Ie(), e.currentRequest = k.post("/api/query", {
        query: e.entitiesQuery,
        variables: {
          entityType: e.schema.dataType,
          pageSize: Number.parseInt(e.currentFilter.pageSize),
          page: Number.parseInt(e.currentFilter.page),
          sortField: e.currentFilter.sortField,
          sortAscending: e.currentFilter.sortAscending,
          filter: e.currentFilter.filter
        }
      }).withCancellationToken(e.cancellationToken).onSuccess((t) => {
        f.debug("Entities loaded successfully", t.data.entities), e.entities = t.data.entities;
      }), await e.currentRequest.send();
    }, 100),
    // opens the listing
    openListing: function() {
      f.debug("Opening listing"), this.mode = "listing", this.loadData();
    },
    // saves an entity
    // event: the event that triggered the save
    // entity: the entity to save
    saveEntity: function(e, t) {
      let a = this;
      if (e.preventDefault(), t != null)
        return this.currentEntity = null, f.debug("Saving entity:", t), k.post("/api/command/v1/SaveModelCommand", {
          data: t,
          entityType: a.schema.dataType,
          id: t.iD
        }).onSuccess((n) => {
          f.debug("Entity saved successfully", n.data), a.mode = "listing", a.loadData();
        }).onError((n) => f.error("Error saving entity", n)).send(), !1;
    }
  },
  props: {
    name: {
      type: String,
      default: ""
    },
    schema: {
      type: Object,
      default: {}
    },
    debug: {
      type: Boolean,
      default: !0
    }
  },
  // create event (load data)
  created: function() {
    this.openListing(), this.loadData();
  },
  watch: {
    // watch for changes to the schema
    schema: function() {
      this.openListing(), this.loadData();
    }
  }
});
const Z = (e) => (B("data-v-c4c98bca"), e = e(), R(), e), Nn = ["title"], Ln = /* @__PURE__ */ Z(() => /* @__PURE__ */ l("span", { class: "fas fa-plus right" }, null, -1)), Pn = [
  Ln
], Bn = /* @__PURE__ */ Z(() => /* @__PURE__ */ l("span", { class: "fas fa-list right" }, null, -1)), Rn = [
  Bn
], zn = { class: "body" }, Un = { key: 0 }, Yn = { key: 1 }, _n = {
  key: 2,
  class: "panel debug"
}, Kn = /* @__PURE__ */ Z(() => /* @__PURE__ */ l("header", null, "Editor Schema", -1));
function Gn(e, t, a, n, o, c) {
  const i = O("listing"), u = O("mithril-form");
  return r(), s("div", {
    class: v(["panel", e.schema.class])
  }, [
    l("header", null, [
      p(h(e.name) + " ", 1),
      e.mode == "listing" ? (r(), s("a", {
        key: 0,
        onClick: t[0] || (t[0] = (m) => e.editEntity({ iD: 0 })),
        title: "Add New " + e.name
      }, Pn, 8, Nn)) : d("", !0),
      e.mode == "editor" ? (r(), s("a", {
        key: 1,
        onClick: t[1] || (t[1] = (...m) => e.openListing && e.openListing(...m)),
        title: "Show Listing"
      }, Rn)) : d("", !0)
    ]),
    l("div", zn, [
      e.mode == "listing" ? (r(), s("div", Un, [
        N(i, {
          schema: e.schema.modelSchema,
          model: e.entities,
          debug: e.debug,
          onEntitySelected: e.editEntity,
          onFilter: e.filter
        }, null, 8, ["schema", "model", "debug", "onEntitySelected", "onFilter"])
      ])) : d("", !0),
      e.mode == "editor" ? (r(), s("div", Yn, [
        N(u, {
          schema: e.schema.modelSchema,
          model: e.currentEntity,
          debug: e.debug,
          onSubmit: e.saveEntity
        }, null, 8, ["schema", "model", "debug", "onSubmit"])
      ])) : d("", !0),
      e.debug && e.schema ? (r(), s("div", _n, [
        Kn,
        l("pre", null, "" + h(e.schema) + `
                `, 1)
      ])) : d("", !0)
    ])
  ], 2);
}
const Hn = /* @__PURE__ */ $(On, [["render", Gn], ["__scopeId", "data-v-c4c98bca"]]), Qn = y.defineComponent({
  name: "admin-application",
  computed: {
    groupedEditors: function() {
      const e = {};
      return this.sortedEditors.forEach((t) => {
        e[t.category] || (e[t.category] = []), e[t.category].push(t);
      }), Object.keys(e).map((t) => ({
        category: t,
        editors: e[t]
      }));
    },
    sortedEditors: function() {
      return this.editors.sort((e, t) => e.category < t.category ? -1 : e.category > t.category ? 1 : e.name < t.name ? -1 : e.name > t.name ? 1 : 0);
    }
  },
  data: function() {
    return {
      editors: [],
      currentEditor: null
    };
  },
  methods: {
    // close the current editor
    close: function() {
      this.editorSelected(null);
    },
    // editor selected
    // editor: the editor that was selected
    editorSelected: function(e) {
      this.debug && f.debug("Switching to editor:", (e == null ? void 0 : e.name) ?? ""), this.currentEditor = e;
    },
    // Loads the editors from the server
    loadEditors: function() {
      this.debug && f.debug("Loading Editors");
      let e = this;
      k.post("/api/query", {
        query: `query{
  editors {
    category
    componentDefinition {
      name
      schema
      scriptFile
    }
    description
    icon
    name
  }
}`
      }).onSuccess((t) => {
        e.editors = t.data.editors, e.debug && f.debug("Finished loading editors:", t.data.editors);
      }).withStorageMode(V.StorageAndUpdate).send();
    }
  },
  props: {
    debug: {
      type: Boolean,
      default: !0
    }
  },
  // created event (loads the editors)
  created: function() {
    this.loadEditors();
  }
});
const Jn = (e) => (B("data-v-280d2014"), e = e(), R(), e), Wn = { class: "main-application" }, Zn = { class: "left-nav panel" }, Xn = { class: "menu" }, xn = ["onClick", "title"], ei = { class: "editor-content" }, ti = {
  key: 1,
  class: "panel debug"
}, ai = /* @__PURE__ */ Jn(() => /* @__PURE__ */ l("header", null, "Selected Editor Info", -1));
function ni(e, t, a, n, o, c) {
  return r(), s("div", Wn, [
    l("div", Zn, [
      (r(!0), s(b, null, S(e.groupedEditors, (i) => (r(), s("section", {
        key: i.category
      }, [
        l("header", null, h(e.$filters.capitalize(i.category)), 1),
        l("ul", Xn, [
          (r(!0), s(b, null, S(i.editors, (u, m) => (r(), s("li", {
            key: u.name
          }, [
            l("a", {
              href: "#!",
              onClick: C((g) => e.editorSelected(u), ["stop", "prevent"]),
              title: u.description,
              class: v({ selected: e.currentEditor == u })
            }, [
              l("span", {
                class: v(u.icon)
              }, null, 2),
              p(h(u.name), 1)
            ], 10, xn)
          ]))), 128))
        ])
      ]))), 128))
    ]),
    l("div", ei, [
      e.currentEditor ? (r(), q(I(e.currentEditor.componentDefinition.schema.type), {
        key: 0,
        schema: e.currentEditor.componentDefinition.schema,
        name: e.currentEditor.name,
        debug: e.debug,
        onError: e.error,
        onClose: e.close
      }, null, 40, ["schema", "name", "debug", "onError", "onClose"])) : d("", !0),
      e.debug && e.currentEditor ? (r(), s("div", ti, [
        ai,
        l("ul", null, [
          l("li", null, " Component Name: " + h(e.currentEditor.componentDefinition.name), 1),
          l("li", null, " Component Type: " + h(e.currentEditor.componentDefinition.schema.type), 1)
        ])
      ])) : d("", !0)
    ])
  ]);
}
const ii = /* @__PURE__ */ $(Qn, [["render", ni], ["__scopeId", "data-v-280d2014"]]);
let E = {
  mounted: function(e, t) {
    if (E.onEventBound = E.onEvent.bind({ el: e }), document.addEventListener("click", E.onEventBound), typeof t.value != "function")
      throw new Error("Argument must be a function");
    E.cb = t.value;
  },
  cb: function(e) {
  },
  onEvent: function(e) {
    e.target === this.el || this.el.contains(e.target) || !E.cb || E.cb(e);
  },
  onEventBound: function() {
  },
  unbind: function() {
    document.removeEventListener("click", E.onEventBound);
  },
  update: function(e, t) {
    if (typeof t.value != "function")
      throw new Error("Argument must be a function");
    E.cb = t.value;
  }
};
function ri(e) {
  return e.directive("click-outside", E), e;
}
function si(e) {
  return e == null || (e.config.globalProperties.$filters = {
    moment: function(t, a, n) {
      return t == null ? "N/A" : (n ?? (n = "YYYY-MM-DDThh:mm:ss"), a ?? (a = "M-D-YYYY h:mm A"), Q(t, n).format(a));
    },
    capitalize: function(t) {
      return t == null ? "" : t.charAt(0).toUpperCase() + t.slice(1);
    },
    maxsize: function(t, a, n) {
      return t == null ? "" : t.length <= a ? t : (n ?? (n = "..."), t.substring(0, a) + n);
    },
    currency: function(t, a, n) {
      return t == null ? "" : (a ?? (a = "en-US"), n ?? (n = { style: "currency", currency: "USD" }), Intl.NumberFormat(a, n).format(t));
    }
  }), e;
}
class ae {
}
const oi = y.defineComponent({
  name: "DataHandler",
  data: function() {
    return {
      count: 0,
      timer: 0,
      internalData: this.model
    };
  },
  props: {
    model: {
      type: Object,
      default: {}
    },
    schema: {
      type: ae,
      default: new ae()
    }
  },
  methods: {
    fetchData: function() {
      if (!this.schema.loadUrl)
        return;
      let e = this;
      k.post("/api/query", {
        query: e.schema.datalistQuery
      }).onSuccess((t) => {
        e.schema.datalist = t.data.dropDown;
      }).withStorageMode(V.StorageAndUpdate).send();
    },
    saveData: function() {
    },
    deleteData: function() {
    }
  },
  created: function() {
    if (!this.schema.datalistQuery)
      return;
    this.fetchData();
  },
  watch: {
    model: function(e, t) {
      t !== e && (this.internalModel = e);
    }
  }
});
function li(e, t, a, n, o, c) {
  return r(), s("div", null, [
    p(" ASDF "),
    (r(!0), s(b, null, S(e.schema.children, (i) => (r(), q(I(i.type), {
      key: i.type,
      data: e.internalData,
      schema: i,
      onSave: e.saveData,
      onDelete: e.deleteData,
      onLoad: e.fetchData
    }, null, 40, ["data", "schema", "onSave", "onDelete", "onLoad"]))), 128)),
    l("pre", null, h(e.internalData), 1)
  ]);
}
const di = /* @__PURE__ */ $(oi, [["render", li]]), ci = y.defineComponent({
  data: function() {
    return {
      items: this.items,
      showDropDown: !1
    };
  },
  props: {
    items: Array
  },
  methods: {
    showDropDownFunc: function() {
      this.showDropDown = !0;
    },
    hideDropDownFunc: function() {
      this.showDropDown = !1;
    }
  },
  directives: {
    clickOutside: E
  }
}), ui = { class: "unstyled" }, hi = { class: "grouped" }, mi = ["href"];
function fi(e, t, a, n, o, c) {
  const i = De("click-outside");
  return j((r(), s("ul", ui, [
    l("li", null, [
      l("a", {
        class: "fas fa-circle-user",
        href: "#",
        onClick: t[0] || (t[0] = C((...u) => e.showDropDownFunc && e.showDropDownFunc(...u), ["stop", "prevent"]))
      }),
      l("div", {
        class: v({ show: e.showDropDown, "z-depth-2": e.showDropDown, hidden: !e.showDropDown })
      }, [
        l("ul", hi, [
          (r(!0), s(b, null, S(e.items, (u) => (r(), s("li", {
            key: u.display
          }, [
            l("a", {
              href: u.url,
              class: v([u.icon])
            }, h(u.display), 11, mi)
          ]))), 128))
        ])
      ], 2)
    ])
  ])), [
    [i, e.hideDropDownFunc]
  ]);
}
const pi = /* @__PURE__ */ $(ci, [["render", fi]]), gi = (e) => {
  e.component("mithril-data-handler", di), e.component("mithril-side-menu", pi);
}, yi = {
  install: (e, t) => {
    si(e), ri(e), gi(e);
  }
};
class bi {
  // constructor
  constructor() {
    // Admin application
    ee(this, "AdminApp");
    f.debug("Admin loading"), this.AdminApp = this.SetupComponents(y.createApp({
      data: function() {
        return {};
      }
    })), this.AdminApp.mount("#AdminApplication"), f.debug("Admin loaded");
  }
  // Sets up Vue components
  SetupComponents(t) {
    return t.use(yi), t.component("admin-application", ii), t.component("settings-editor-component", bn), t.component("data-editor-component", Hn), t;
  }
}
const ki = (() => {
  new bi();
})();
export {
  ki as default
};
